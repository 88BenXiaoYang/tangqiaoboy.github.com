
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>基于 CoreText 的排版引擎：基础 | 唐巧的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="唐巧">
    

    
    <meta name="description" content="版权说明原创文章，转载请保留以下信息：

本文节选自我的图书：《iOS 开发进阶 》。
本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。
扫码关注我的「iOS 开发」微信公众帐号：



本章前言使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText">
<meta property="og:type" content="article">
<meta property="og:title" content="基于 CoreText 的排版引擎：基础">
<meta property="og:url" content="http://blog.devtang.com/2015/06/27/using-coretext-1/index.html">
<meta property="og:site_name" content="唐巧的博客">
<meta property="og:description" content="版权说明原创文章，转载请保留以下信息：

本文节选自我的图书：《iOS 开发进阶 》。
本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。
扫码关注我的「iOS 开发」微信公众帐号：



本章前言使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText">
<meta property="og:image" content="http://blog.devtang.com/images/weixin-qr.jpg">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext_arch.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-1.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-2.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-3.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-create-ctdisplayview.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-4.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-5.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-flip.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-shape.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-un-select-autolayout.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-uml.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-attribute-string-as-argument.png">
<meta property="og:image" content="http://tangqiao.b0.upaiyun.com/coretext/coretext-load-from-json-template.png">
<meta property="og:updated_time" content="2016-06-19T03:14:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基于 CoreText 的排版引擎：基础">
<meta name="twitter:description" content="版权说明原创文章，转载请保留以下信息：

本文节选自我的图书：《iOS 开发进阶 》。
本文涉及的 Demo 工程在这里：https://github.com/tangqiaoboy/iOS-Pro。
扫码关注我的「iOS 开发」微信公众帐号：



本章前言使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText">

    
    <link rel="alternative" href="/atom.xml" title="唐巧的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.png">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="唐巧的博客">唐巧的博客</a></h1>
				<h2 class="blog-motto">记录下自己学习的点滴</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:blog.devtang.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/27/using-coretext-1/" title="基于 CoreText 的排版引擎：基础" itemprop="url">基于 CoreText 的排版引擎：基础</a>
  </h1>
  
  <p class="article-time">
    <time datetime="2015-06-27T00:39:56.000Z" itemprop="datePublished"> 发表于 2015-06-27 08:39</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7248_u6743_u8BF4_u660E"><span class="toc-number">1.</span> <span class="toc-text">版权说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u672C_u7AE0_u524D_u8A00"><span class="toc-number">2.</span> <span class="toc-text">本章前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CoreText__u7B80_u4ECB"><span class="toc-number">3.</span> <span class="toc-text">CoreText 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u57FA_u4E8E_CoreText__u7684_u57FA_u7840_u6392_u7248_u5F15_u64CE"><span class="toc-number">4.</span> <span class="toc-text">基于 CoreText 的基础排版引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E0D_u5E26_u56FE_u7247_u7684_u6392_u7248_u5F15_u64CE"><span class="toc-number">4.1.</span> <span class="toc-text">不带图片的排版引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u80FD_u8F93_u51FA_Hello_World__u7684_CoreText__u5DE5_u7A0B"><span class="toc-number">5.</span> <span class="toc-text">能输出 Hello World 的 CoreText 工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u64CD_u4F5C_u6B65_u9AA4"><span class="toc-number">5.1.</span> <span class="toc-text">操作步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u4EE3_u7801_u57FA_u672C_u7684_u5B8F_u5B9A_u4E49_u548C_Category"><span class="toc-number">5.1.1.</span> <span class="toc-text">代码基本的宏定义和 Category</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6392_u7248_u5F15_u64CE_u6846_u67B6"><span class="toc-number">6.</span> <span class="toc-text">排版引擎框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5B9A_u5236_u6392_u7248_u6587_u4EF6_u683C_u5F0F"><span class="toc-number">7.</span> <span class="toc-text">定制排版文件格式</span></a></li></ol>
		
		</div>
		
		<h2 id="u7248_u6743_u8BF4_u660E"><a href="#u7248_u6743_u8BF4_u660E" class="headerlink" title="版权说明"></a>版权说明</h2><p>原创文章，转载请保留以下信息：</p>
<ul>
<li>本文节选自我的图书：《<a href="http://item.jd.com/11598468.html" target="_blank">iOS 开发进阶 </a>》。</li>
<li>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro</a>。</li>
<li><p>扫码关注我的「iOS 开发」微信公众帐号：</p>
<p><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="二维码"></p>
</li>
</ul>
<h2 id="u672C_u7AE0_u524D_u8A00"><a href="#u672C_u7AE0_u524D_u8A00" class="headerlink" title="本章前言"></a>本章前言</h2><p>使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。</p>
<p>本章我们将从最基本的开始，一步一步完成一个支持图文混排、支持图片和链接点击的排版引擎。</p>
<h2 id="CoreText__u7B80_u4ECB"><a href="#CoreText__u7B80_u4ECB" class="headerlink" title="CoreText 简介"></a>CoreText 简介</h2><p>CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。</p>
<p>Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。</p>
<p>下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。</p>
<blockquote>
<p>注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。</p>
</blockquote>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext_arch.png" alt="CoreText 的架构图"></p>
<p>UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处：</p>
<ul>
<li>CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。</li>
<li>CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取）</li>
<li>CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。</li>
<li>基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。</li>
</ul>
<p>当然，基于 CoreText 的排版方案也有一些劣势：</p>
<ul>
<li>CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。</li>
<li>基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。</li>
</ul>
<p>在业界，很多应用都采用了基于 CoreText 技术的排版方案，例如：新浪微博客户端，多看阅读客户端。我所在的创业公司的猿题库，也使用了自己基于 CoreText 技术实现的排版引擎，下图是我们产品的一个图文混排的界面（其中所有公式都是用图片的方式呈现的），可以看到，图片和文字排版效果很好。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-1.png" alt="猿题库的采用 CoreText 渲染的界面"></p>
<h2 id="u57FA_u4E8E_CoreText__u7684_u57FA_u7840_u6392_u7248_u5F15_u64CE"><a href="#u57FA_u4E8E_CoreText__u7684_u57FA_u7840_u6392_u7248_u5F15_u64CE" class="headerlink" title="基于 CoreText 的基础排版引擎"></a>基于 CoreText 的基础排版引擎</h2><h3 id="u4E0D_u5E26_u56FE_u7247_u7684_u6392_u7248_u5F15_u64CE"><a href="#u4E0D_u5E26_u56FE_u7247_u7684_u6392_u7248_u5F15_u64CE" class="headerlink" title="不带图片的排版引擎"></a>不带图片的排版引擎</h3><p>下面我们来尝试完成一个基于 CoreText 的排版引擎。我们将从最简单的排版功能开始，然后逐步支持图文混排，链接点击等功能。</p>
<p>首先我们来尝试完成一个不支持图片内容的纯文字排版引擎。</p>
<p>注意 1：由于整个排版引擎的代码太多，为方便读者阅读，文章中只会列出最关键的核心代码，完整的代码请参考本书对应的 github 项目，项目地址是：<a href="https://github.com/tangqiaoboy/iOS-Pro" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro</a> 。</p>
<h2 id="u80FD_u8F93_u51FA_Hello_World__u7684_CoreText__u5DE5_u7A0B"><a href="#u80FD_u8F93_u51FA_Hello_World__u7684_CoreText__u5DE5_u7A0B" class="headerlink" title="能输出 Hello World 的 CoreText 工程"></a>能输出 Hello World 的 CoreText 工程</h2><h3 id="u64CD_u4F5C_u6B65_u9AA4"><a href="#u64CD_u4F5C_u6B65_u9AA4" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>我们首先新建一个 Xcode 工程，步骤如下：</p>
<ol>
<li>打开 Xcode，选择 “File”-&gt;”New”-&gt;”Project”, 在弹出的对话框中，选择 “Single View Application”，然后点击 “Next”。（图 2）</li>
<li>接着填上项目名 CoreTextDemo，然后点击 “Next”。（图 3）</li>
<li><p>选择保存目录后，我们就成功创建了一个空的工程。</p>
<p>图 2<br><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-2.png" alt="图 2"></p>
<p>图 3<br><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-3.png" alt="图 3"></p>
</li>
</ol>
<p>在工程目录 “CoreTextDemo” 上右击，选择 “New File”, 然后填入类名<code>CTDisplayView</code>, 并且让它的父类是 UIView。（如下图）</p>
<p> <img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-create-ctdisplayview.png" alt=""></p>
<p>接着，我们在<code>CTDisplayView.m</code>文件中，让其 import 头文件<code>CoreText/CoreText.h</code>，接着输入以下代码来实现其<code>drawRect</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#34;CTDisplayView.h&#34;&#10;#import &#34;CoreText/CoreText.h&#34;&#10;&#10;@implementation CTDisplayView&#10;&#10;- (void)drawRect:(CGRect)rect&#10;&#123;&#10;    [super drawRect:rect];&#10;&#10;    // &#27493;&#39588; 1&#10;    CGContextRef context = UIGraphicsGetCurrentContext();&#10;&#10;    // &#27493;&#39588; 2&#10;    CGContextSetTextMatrix(context, CGAffineTransformIdentity);&#10;    CGContextTranslateCTM(context, 0, self.bounds.size.height);&#10;    CGContextScaleCTM(context, 1.0, -1.0);&#10;&#10;    // &#27493;&#39588; 3&#10;    CGMutablePathRef path = CGPathCreateMutable();&#10;    CGPathAddRect(path, NULL, self.bounds);&#10;&#10;    // &#27493;&#39588; 4&#10;    NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@&#34;Hello World!&#34;];&#10;    CTFramesetterRef framesetter =&#10;    CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attString);&#10;    CTFrameRef frame =&#10;    CTFramesetterCreateFrame(framesetter,&#10;                             CFRangeMake(0, [attString length]), path, NULL);&#10;&#10;    // &#27493;&#39588; 5&#10;    CTFrameDraw(frame, context);&#10;&#10;    // &#27493;&#39588; 6&#10;    CFRelease(frame);&#10;    CFRelease(path);&#10;    CFRelease(framesetter);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>打开程序的 Storyboard 文件：<code>Main_iPhone.storyboard</code>：执行下面 2 步：</p>
<ol>
<li>将一个 UIView 控件拖动到主界面正中间。（如下图步骤 1）</li>
<li>将该 UIView 控件的类名从<code>UIView</code>修改为<code>CTDisplayView</code>。（如下图步骤 2）</li>
</ol>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-4.png" alt="图 4"></p>
<p>之后，我们运行程序，就可以看到，Hello World 出现在程序正中间了。如下图。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-5.png" alt="图 5"></p>
<p>###代码解释</p>
<p>下面解释一下<code>drawRect</code>方法主要的步骤：</p>
<ol>
<li>得到当前绘制画布的上下文，用于后续将内容绘制在画布上。</li>
<li><p>将坐标系上下翻转。对于底层的绘制引擎来说，屏幕的左下角是（0, 0）坐标。而对于上层的 UIKit 来说，左上角是 (0, 0) 坐标。所以我们为了之后的坐标系描述按 UIKit 来做，所以先在这里做一个坐标系的上下翻转操作。翻转之后，底层和上层的 (0, 0) 坐标就是重合的了。</p>
<p>为了加深理解，我们将这部分的代码块注释掉，你会发现，整个<code>Hello World</code>界面将上下翻转，如下图所示。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-flip.png" alt="图：上下翻转的界面"></p>
</li>
</ol>
<ol>
<li>创建绘制的区域，CoreText 本身支持各种文字排版的区域，我们这里简单地将 UIView 的整个界面作为排版的区域。</li>
</ol>
<p>为了加深理解，我们将该步骤的代码替换成如下代码，测试设置不同的绘制区域带来的界面变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#27493;&#39588; 3&#10;CGMutablePathRef path = CGPathCreateMutable();&#10;CGPathAddEllipseInRect(path, NULL, self.bounds);&#10;&#10;// &#27493;&#39588; 4&#10;NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@&#34;Hello World! &#34;&#10;                                 &#34; &#21019;&#24314;&#32472;&#21046;&#30340;&#21306;&#22495;&#65292;CoreText &#26412;&#36523;&#25903;&#25345;&#21508;&#31181;&#25991;&#23383;&#25490;&#29256;&#30340;&#21306;&#22495;&#65292;&#34;&#10;                                 &#34; &#25105;&#20204;&#36825;&#37324;&#31616;&#21333;&#22320;&#23558; UIView &#30340;&#25972;&#20010;&#30028;&#38754;&#20316;&#20026;&#25490;&#29256;&#30340;&#21306;&#22495;&#12290;&#34;&#10;                                 &#34; &#20026;&#20102;&#21152;&#28145;&#29702;&#35299;&#65292;&#24314;&#35758;&#35835;&#32773;&#23558;&#35813;&#27493;&#39588;&#30340;&#20195;&#30721;&#26367;&#25442;&#25104;&#22914;&#19979;&#20195;&#30721;&#65292;&#34;&#10;                                 &#34; &#27979;&#35797;&#35774;&#32622;&#19981;&#21516;&#30340;&#32472;&#21046;&#21306;&#22495;&#24102;&#26469;&#30340;&#30028;&#38754;&#21464;&#21270;&#12290;&#34;];</span><br></pre></td></tr></table></figure>
<p>执行结果如下图所示：</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-shape.png" alt="图：椭圆形的排版区域"></p>
<h4 id="u4EE3_u7801_u57FA_u672C_u7684_u5B8F_u5B9A_u4E49_u548C_Category"><a href="#u4EE3_u7801_u57FA_u672C_u7684_u5B8F_u5B9A_u4E49_u548C_Category" class="headerlink" title="代码基本的宏定义和 Category"></a>代码基本的宏定义和 Category</h4><p>为了方便我们的代码编写，我在<code>CoreTextDemo-Prefix.pch</code>文件中增加了以下基本的宏定义，以方便我们使用 NSLog 和 UIColor。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;#ifdef DEBUG&#10;#define debugLog(...) NSLog(__VA_ARGS__)&#10;#define debugMethod() NSLog(@&#34;%s&#34;, __func__)&#10;#else&#10;#define debugLog(...)&#10;#define debugMethod()&#10;#endif&#10;&#10;#define RGB(A, B, C)    [UIColor colorWithRed:A/255.0 green:B/255.0 blue:C/255.0 alpha:1.0]</span><br></pre></td></tr></table></figure>
<p>我也为 UIView 的 frame 调整增加了一些扩展，可以方便地调整 UIView 的 x, y, width, height 等值。部分关键代码如下（完整的代码请查看示例工程）：</p>
<p>UIView+frameAdjust.h 文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#60;Foundation/Foundation.h&#62;&#10;&#10;@interface UIView (frameAdjust)&#10;&#10;- (CGFloat)x;&#10;- (void)setX:(CGFloat)x;&#10;&#10;- (CGFloat)y;&#10;- (void)setY:(CGFloat)y;&#10;&#10;- (CGFloat)height;&#10;- (void)setHeight:(CGFloat)height;&#10;&#10;- (CGFloat)width;&#10;- (void)setWidth:(CGFloat)width;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>UIView+frameAdjust.m 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation UIView (frameAdjust)&#10;- (CGFloat)x &#123;&#10;    return self.frame.origin.x;&#10;&#125;&#10;&#10;- (void)setX:(CGFloat)x &#123;&#10;    self.frame = CGRectMake(x, self.y, self.width, self.height);&#10;&#125;&#10;&#10;- (CGFloat)y &#123;&#10;    return self.frame.origin.y;&#10;&#125;&#10;&#10;- (void)setY:(CGFloat)y &#123;&#10;    self.frame = CGRectMake(self.x, y, self.width, self.height);&#10;&#125;&#10;&#10;- (CGFloat)height &#123;&#10;    return self.frame.size.height;&#10;&#125;&#10;- (void)setHeight:(CGFloat)height &#123;&#10;    self.frame = CGRectMake(self.x, self.y, self.width, height);&#10;&#125;&#10;&#10;- (CGFloat)width &#123;&#10;    return self.frame.size.width;&#10;&#125;&#10;- (void)setWidth:(CGFloat)width &#123;&#10;    self.frame = CGRectMake(self.x, self.y, width, self.height);&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>文章中的其余代码默认都#import 了以上提到的宏定义和 UIView Category。</p>
<h2 id="u6392_u7248_u5F15_u64CE_u6846_u67B6"><a href="#u6392_u7248_u5F15_u64CE_u6846_u67B6" class="headerlink" title="排版引擎框架"></a>排版引擎框架</h2><p>上面的 Hello World 工程仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 <code>CTDisplayView</code> 的<code>drawRect</code>方法里面。根据设计模式中的 “ 单一功能原则 “(<code>Single responsibility principle</code>)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。</p>
<p>对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成：</p>
<ol>
<li>一个显示用的类，仅负责显示内容，不负责排版</li>
<li>一个模型类，用于承载显示所需要的所有数据</li>
<li>一个排版类，用于实现文字内容的排版</li>
<li>一个配置类，用于实现一些排版时的可配置项</li>
</ol>
<p>注：” 单一功能原则 “(<code>Single responsibility principle</code>)<br>参考链接：<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99</a></p>
<p>按照以上原则，我们将<code>CTDisplayView</code>中的部分内容拆开，由 4 个类构成：</p>
<ol>
<li><code>CTFrameParserConfig</code>类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。</li>
<li><code>CTFrameParser</code>类，用于生成最后绘制界面需要的<code>CTFrameRef</code>实例。</li>
<li><code>CoreTextData</code>类，用于保存由<code>CTFrameParser</code>类生成的<code>CTFrameRef</code>实例以及<code>CTFrameRef</code>实际绘制需要的高度。</li>
<li><code>CTDisplayView</code>类，持有<code>CoreTextData</code>类的实例，负责将<code>CTFrameRef</code>绘制到界面上。</li>
</ol>
<p>关于这 4 个类的关键代码如下：</p>
<p><code>CTFrameParserConfig</code>类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#60;Foundation/Foundation.h&#62;&#10;@interface CTFrameParserConfig : NSObject&#10;&#10;@property (nonatomic, assign) CGFloat width;&#10;@property (nonatomic, assign) CGFloat fontSize;&#10;@property (nonatomic, assign) CGFloat lineSpace;&#10;@property (nonatomic, strong) UIColor *textColor;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;#import &#34;CTFrameParserConfig.h&#34;&#10;&#10;@implementation CTFrameParserConfig&#10;&#10;- (id)init &#123;&#10;    self = [super init];&#10;    if (self) &#123;&#10;        _width = 200.0f;&#10;        _fontSize = 16.0f;&#10;        _lineSpace = 8.0f;&#10;        _textColor = RGB(108, 108, 108);&#10;    &#125;&#10;    return self;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><code>CTFrameParser</code>类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#60;Foundation/Foundation.h&#62;&#10;#import &#34;CoreTextData.h&#34;&#10;#import &#34;CTFrameParserConfig.h&#34;&#10;&#10;@interface CTFrameParser : NSObject&#10;&#10;+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;#import &#34;CTFrameParser.h&#34;&#10;#import &#34;CTFrameParserConfig.h&#34;&#10;&#10;@implementation CTFrameParser&#10;&#10;+ (NSDictionary *)attributesWithConfig:(CTFrameParserConfig *)config &#123;&#10;    CGFloat fontSize = config.fontSize;&#10;    CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&#34;ArialMT&#34;, fontSize, NULL);&#10;    CGFloat lineSpacing = config.lineSpace;&#10;    const CFIndex kNumberOfSettings = 3;&#10;    CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123;&#10;        &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &#38;lineSpacing &#125;,&#10;        &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &#38;lineSpacing &#125;,&#10;        &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &#38;lineSpacing &#125;&#10;    &#125;;&#10;&#10;    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings);&#10;&#10;    UIColor * textColor = config.textColor;&#10;&#10;    NSMutableDictionary * dict = [NSMutableDictionary dictionary];&#10;    dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor;&#10;    dict[(id)kCTFontAttributeName] = (__bridge id)fontRef;&#10;    dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef;&#10;&#10;    CFRelease(theParagraphRef);&#10;    CFRelease(fontRef);&#10;    return dict;&#10;&#125;&#10;&#10;+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config &#123;&#10;    NSDictionary *attributes = [self attributesWithConfig:config];&#10;    NSAttributedString *contentString =&#10;        [[NSAttributedString alloc] initWithString:content&#10;                                        attributes:attributes];&#10;&#10;    // &#21019;&#24314; CTFramesetterRef &#23454;&#20363;&#10;    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)contentString);&#10;&#10;    // &#33719;&#24471;&#35201;&#32472;&#21046;&#30340;&#21306;&#22495;&#30340;&#39640;&#24230;&#10;    CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX);&#10;    CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil);&#10;    CGFloat textHeight = coreTextSize.height;&#10;&#10;    // &#29983;&#25104; CTFrameRef &#23454;&#20363;&#10;    CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight];&#10;&#10;    // &#23558;&#29983;&#25104;&#22909;&#30340; CTFrameRef &#23454;&#20363;&#21644;&#35745;&#31639;&#22909;&#30340;&#32472;&#21046;&#39640;&#24230;&#20445;&#23384;&#21040; CoreTextData &#23454;&#20363;&#20013;&#65292;&#26368;&#21518;&#36820;&#22238; CoreTextData &#23454;&#20363;&#10;    CoreTextData *data = [[CoreTextData alloc] init];&#10;    data.ctFrame = frame;&#10;    data.height = textHeight;&#10;&#10;    // &#37322;&#25918;&#20869;&#23384;&#10;    CFRelease(frame);&#10;    CFRelease(framesetter);&#10;    return data;&#10;&#125;&#10;&#10;+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter&#10;                                  config:(CTFrameParserConfig *)config&#10;                                  height:(CGFloat)height &#123;&#10;&#10;    CGMutablePathRef path = CGPathCreateMutable();&#10;    CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height));&#10;&#10;    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);&#10;    CFRelease(path);&#10;    return frame;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><code>CoreTextData</code>类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#60;Foundation/Foundation.h&#62;&#10;&#10;@interface CoreTextData : NSObject&#10;&#10;@property (assign, nonatomic) CTFrameRef ctFrame;&#10;@property (assign, nonatomic) CGFloat height;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#34;CoreTextData.h&#34;&#10;&#10;@implementation CoreTextData&#10;&#10;- (void)setCtFrame:(CTFrameRef)ctFrame &#123;&#10;    if (_ctFrame != ctFrame) &#123;&#10;        if (_ctFrame != nil) &#123;&#10;            CFRelease(_ctFrame);&#10;        &#125;&#10;        CFRetain(ctFrame);&#10;        _ctFrame = ctFrame;&#10;    &#125;&#10;&#125;&#10;&#10;- (void)dealloc &#123;&#10;    if (_ctFrame != nil) &#123;&#10;        CFRelease(_ctFrame);&#10;        _ctFrame = nil;&#10;    &#125;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p><code>CTDisplayView</code>类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#60;Foundation/Foundation.h&#62;&#10;#import &#34;CoreTextData.h&#34;&#10;&#10;@interface CTDisplayView : UIView&#10;&#10;@property (strong, nonatomic) CoreTextData * data;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#34;CTDisplayView.h&#34;&#10;&#10;@implementation CTDisplayView&#10;&#10;- (void)drawRect:(CGRect)rect&#10;&#123;&#10;    [super drawRect:rect];&#10;    CGContextRef context = UIGraphicsGetCurrentContext();&#10;    CGContextSetTextMatrix(context, CGAffineTransformIdentity);&#10;    CGContextTranslateCTM(context, 0, self.bounds.size.height);&#10;    CGContextScaleCTM(context, 1.0, -1.0);&#10;&#10;    if (self.data) &#123;&#10;        CTFrameDraw(self.data.ctFrame, context);&#10;    &#125;&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>以上 4 个类中的逻辑与之前 Hello World 那个项目的逻辑基本一致，只是分拆到了 4 个类中完成。另外，CTFrameParser 增加了方法来获得要绘制的区域的高度，并将高度信息保存到<code>CoreTextData</code>类的实例中。之所以要获得绘制区域的高度，是因为在很多实际使用场景中，我们需要先知道所要显示内容的高度，之后才可以进行绘制。</p>
<p>例如，在 UITableView 在渲染时，UITableView 首先会向 delegate 回调如下方法来获得每个将要渲染的 cell 的高度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure>
<p>之后，UITableView 会计算当前滚动的位置具体需要绘制的 UITableViewCell 是哪些，然后对于那些需要绘制的 Cell，UITableView 才会继续向其 data source 回调如下方法来获得 UITableViewCell 实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure>
<p>对于上面的情况，如果我们使用 CoreText 来作为 TableViewCell 的内容，那么就必须在每个 Cell 绘制之前，就知道其需要的绘制高度，否则 UITableView 将无法正常工作。</p>
<p>完成以上 4 个类之后，我们就可以简单地在<code>ViewController.m</code>文件中，加入如下代码来配置<code>CTDisplayView</code>的显示内容，位置，高度，字体，颜色等信息。代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#34;ViewController.h&#34;&#10;&#10;@interface ViewController ()&#10;&#10;@property (weak, nonatomic) IBOutlet CTDisplayView *ctView;&#10;&#10;@end&#10;&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];&#10;    config.textColor = [UIColor redColor];&#10;    config.width = self.ctView.width;&#10;&#10;    CoreTextData *data = [CTFrameParser parseContent:@&#34; &#25353;&#29031;&#20197;&#19978;&#21407;&#21017;&#65292;&#25105;&#20204;&#23558;`CTDisplayView`&#20013;&#30340;&#37096;&#20998;&#20869;&#23481;&#25286;&#24320;&#12290;&#34; config:config];&#10;    self.ctView.data = data;&#10;    self.ctView.height = data.height;&#10;    self.ctView.backgroundColor = [UIColor yellowColor];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>注意：从 Xcode4.0 开始，默认的界面编辑就开启了对于<code>Use Autolayout</code>的使用，但因为我们在代码中直接修改了变量<code>ctView</code>的 frame 信息，所以需要在<code>Main_iPhone.storyboard</code>中将<code>Use Autolayout</code>这一项取消勾选。如下图所示：</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-un-select-autolayout.png" alt="图：取消勾选 Autolayout"></p>
<p>以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的：</p>
<ol>
<li><code>CTFrameParser</code>通过<code>CTFrameparserConfig</code>实例来生成<code>CoreTextData</code>实例。</li>
<li><code>CTDisplayView</code>通过持有<code>CoreTextData</code>实例来获得绘制所需要的所有信息。</li>
<li><code>ViewController</code>类通过配置<code>CTFrameparserConfig</code>实例，进而获得生成的<code>CoreTextData</code>实例，最后将其赋值给他的<code>CTDisplayView</code>成员，达到将指定内容显示在界面上的效果。</li>
</ol>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uml.png" alt="图：UML 示意图"></p>
<p>说明 1：整个工程代码在名为<code>basic_arch</code>的分支下，读者可以在示例的源代码工程中使用<code>git checkout basic_arch</code>来切换到当前讲解的工程示例代码。</p>
<p>说明 2：为了方便操作<code>UIView</code>的<code>frame</code>属性，项目中增加了一个名为<code>UIView+frameAdjust.m</code>文件，它通过<code>Category</code>来给<code>UIView</code>增加了直接设置<code>height</code>属性的方法。</p>
<h2 id="u5B9A_u5236_u6392_u7248_u6587_u4EF6_u683C_u5F0F"><a href="#u5B9A_u5236_u6392_u7248_u6587_u4EF6_u683C_u5F0F" class="headerlink" title="定制排版文件格式"></a>定制排版文件格式</h2><p>对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。</p>
<p>解决的办法很简单，我们让<code>CTFrameParser</code>支持接受 NSAttributeString 作为参数，然后在<code>ViewController</code>类中设置我们想要的 NSAttributeString 信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];&#10;    config.width = self.ctView.width;&#10;    config.textColor = [UIColor blackColor];&#10;&#10;    NSString *content =&#10;        @&#34; &#23545;&#20110;&#19978;&#38754;&#30340;&#20363;&#23376;&#65292;&#25105;&#20204;&#32473; CTFrameParser &#22686;&#21152;&#20102;&#19968;&#20010;&#23558; NSString &#36716; &#34;&#10;         &#34; &#25442;&#20026; CoreTextData &#30340;&#26041;&#27861;&#12290;&#34;&#10;         &#34; &#20294;&#36825;&#26679;&#30340;&#23454;&#29616;&#26041;&#24335;&#26377;&#24456;&#22810;&#23616;&#38480;&#24615;&#65292;&#22240;&#20026;&#25972;&#20010;&#20869;&#23481;&#34429;&#28982;&#21487;&#20197;&#23450;&#21046;&#23383;&#20307; &#34;&#10;         &#34; &#22823;&#23567;&#65292;&#39068;&#33394;&#65292;&#34892;&#39640;&#31561;&#20449;&#24687;&#65292;&#20294;&#26159;&#21364;&#19981;&#33021;&#25903;&#25345;&#23450;&#21046;&#20869;&#23481;&#20013;&#30340;&#26576;&#19968;&#37096;&#20998;&#12290;&#34;&#10;         &#34; &#20363;&#22914;&#65292;&#22914;&#26524;&#25105;&#20204;&#21482;&#24819;&#35753;&#20869;&#23481;&#30340;&#21069;&#19977;&#20010;&#23383;&#26174;&#31034;&#25104;&#32418;&#33394;&#65292;&#32780;&#20854;&#23427;&#25991;&#23383;&#26174; &#34;&#10;         &#34; &#31034;&#25104;&#40657;&#33394;&#65292;&#37027;&#20040;&#23601;&#21150;&#19981;&#21040;&#20102;&#12290;&#34;&#10;         &#34;\n\n&#34;&#10;         &#34; &#35299;&#20915;&#30340;&#21150;&#27861;&#24456;&#31616;&#21333;&#65292;&#25105;&#20204;&#35753;`CTFrameParser`&#25903;&#25345;&#25509;&#21463; &#34;&#10;         &#34;NSAttributeString &#20316;&#20026;&#21442;&#25968;&#65292;&#28982;&#21518;&#22312; NSAttributeString &#20013;&#35774;&#32622;&#22909; &#34;&#10;         &#34; &#25105;&#20204;&#24819;&#35201;&#30340;&#20449;&#24687;&#12290;&#34;;&#10;    NSDictionary *attr = [CTFrameParser attributesWithConfig:config];&#10;    NSMutableAttributedString *attributedString =&#10;         [[NSMutableAttributedString alloc] initWithString:content&#10;                                                attributes:attr];&#10;    [attributedString addAttribute:NSForegroundColorAttributeName&#10;                             value:[UIColor redColor]&#10;                             range:NSMakeRange(0, 7)];&#10;&#10;    CoreTextData *data = [CTFrameParser parseAttributedContent:attributedString&#10;                                                        config:config];&#10;    self.ctView.data = data;&#10;    self.ctView.height = data.height;&#10;    self.ctView.backgroundColor = [UIColor yellowColor];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>结果如下图所示，我们很方便就把前面 7 个字变成了红色。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-attribute-string-as-argument.png" alt=""></p>
<p>更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的内容、颜色、字体大小等信息。我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。</p>
<p>我们规定排版的模版文件为 JSON 格式。JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。iOS 从 5.0 开始，提供了名为<code>NSJSONSerialization</code>的类库来方便开发者对 JSON 的解析。在 iOS5.0 之前，业界也有很多相关的 JSON 解析开源库，例如 JSONKit 可供大家使用。</p>
<p>我们的排版模版示例文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &#123; &#34;color&#34; : &#34;blue&#34;,&#10;    &#34;content&#34; : &#34; &#26356;&#36827;&#19968;&#27493;&#22320;&#65292;&#23454;&#38469;&#24037;&#20316;&#20013;&#65292;&#25105;&#20204;&#26356;&#24076;&#26395;&#36890;&#36807;&#19968;&#20010;&#25490;&#29256;&#25991;&#20214;&#65292;&#26469;&#35774;&#32622;&#38656;&#35201;&#25490;&#29256;&#30340;&#25991;&#23383;&#30340; &#34;,&#10;    &#34;size&#34; : 16,&#10;    &#34;type&#34; : &#34;txt&#34;&#10;  &#125;,&#10;  &#123; &#34;color&#34; : &#34;red&#34;,&#10;    &#34;content&#34; : &#34; &#20869;&#23481;&#12289;&#39068;&#33394;&#12289;&#23383;&#20307; &#34;,&#10;    &#34;size&#34; : 22,&#10;    &#34;type&#34; : &#34;txt&#34;&#10;  &#125;,&#10;  &#123; &#34;color&#34; : &#34;black&#34;,&#10;    &#34;content&#34; : &#34; &#22823;&#23567;&#31561;&#20449;&#24687;&#12290;\n&#34;,&#10;    &#34;size&#34; : 16,&#10;    &#34;type&#34; : &#34;txt&#34;&#10;  &#125;,&#10;  &#123; &#34;color&#34; : &#34;default&#34;,&#10;    &#34;content&#34; : &#34; &#25105;&#22312;&#24320;&#21457;&#29503;&#39064;&#24211;&#24212;&#29992;&#26102;&#65292;&#33258;&#24049;&#23450;&#20041;&#20102;&#19968;&#20010;&#22522;&#20110; UBB &#30340;&#25490;&#29256;&#27169;&#29256;&#65292;&#20294;&#26159;&#23454;&#29616;&#35813;&#25490;&#29256;&#25991;&#20214;&#30340;&#35299;&#26512;&#22120;&#35201;&#33457;&#36153;&#22823;&#37327;&#30340;&#31687;&#24133;&#65292;&#32771;&#34385;&#21040;&#36825;&#24182;&#19981;&#26159;&#26412;&#31456;&#30340;&#37325;&#28857;&#65292;&#25152;&#20197;&#25105;&#20204;&#20197;&#19968;&#20010;&#36739;&#31616;&#21333;&#30340;&#25490;&#29256;&#25991;&#20214;&#26469;&#35762;&#35299;&#20854;&#24605;&#24819;&#12290;&#34;,&#10;    &#34;type&#34; : &#34;txt&#34;&#10;  &#125;&#10;]</span><br></pre></td></tr></table></figure>
<p>通过苹果提供的<code>NSJSONSerialization</code>类，我们可以将上面的模版文件转换成 NSArray 数组，每一个数组元素是一个 NSDictionary，代表一段相同设置的文字。为了简单，我们的配置文件只支持配置颜色和字号，但是读者可以依据同样的思想，很方便地增加其它配置信息。</p>
<p>接下来我们要为<code>CTFrameParser</code>增加一个方法，让其可以从如上格式的模版文件中生成<code>CoreTextData</code>。最终我们的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;// &#26041;&#27861;&#19968;&#10;+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123;&#10;    NSAttributedString *content = [self loadTemplateFile:path config:config];&#10;    return [self parseAttributedContent:content config:config];&#10;&#125;&#10;&#10;// &#26041;&#27861;&#20108;&#10;+ (NSAttributedString *)loadTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123;&#10;    NSData *data = [NSData dataWithContentsOfFile:path];&#10;    NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init];&#10;    if (data) &#123;&#10;        NSArray *array = [NSJSONSerialization JSONObjectWithData:data&#10;                                           options:NSJSONReadingAllowFragments&#10;                                             error:nil];&#10;        if ([array isKindOfClass:[NSArray class]]) &#123;&#10;            for (NSDictionary *dict in array) &#123;&#10;                NSString *type = dict[@&#34;type&#34;];&#10;                if ([type isEqualToString:@&#34;txt&#34;]) &#123;&#10;                    NSAttributedString *as =&#10;                       [self parseAttributedContentFromNSDictionary:dict&#10;                                                             config:config];&#10;                    [result appendAttributedString:as];&#10;                &#125;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;    return result;&#10;&#125;&#10;&#10;// &#26041;&#27861;&#19977;&#10;+ (NSAttributedString *)parseAttributedContentFromNSDictionary:(NSDictionary *)dict&#10;                                                        config:(CTFrameParserConfig*)config &#123;&#10;    NSMutableDictionary *attributes = [self attributesWithConfig:config];&#10;    // set color&#10;    UIColor *color = [self colorFromTemplate:dict[@&#34;color&#34;]];&#10;    if (color) &#123;&#10;        attributes[(id)kCTForegroundColorAttributeName] = (id)color.CGColor;&#10;    &#125;&#10;    // set font size&#10;    CGFloat fontSize = [dict[@&#34;size&#34;] floatValue];&#10;    if (fontSize &#62; 0) &#123;&#10;        CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&#34;ArialMT&#34;, fontSize, NULL);&#10;        attributes[(id)kCTFontAttributeName] = (__bridge id)fontRef;&#10;        CFRelease(fontRef);&#10;    &#125;&#10;    NSString *content = dict[@&#34;content&#34;];&#10;    return [[NSAttributedString alloc] initWithString:content attributes:attributes];&#10;&#125;&#10;&#10;// &#26041;&#27861;&#22235;&#10;+ (UIColor *)colorFromTemplate:(NSString *)name &#123;&#10;    if ([name isEqualToString:@&#34;blue&#34;]) &#123;&#10;        return [UIColor blueColor];&#10;    &#125; else if ([name isEqualToString:@&#34;red&#34;]) &#123;&#10;        return [UIColor redColor];&#10;    &#125; else if ([name isEqualToString:@&#34;black&#34;]) &#123;&#10;        return [UIColor blackColor];&#10;    &#125; else &#123;&#10;        return nil;&#10;    &#125;&#10;&#125;&#10;&#10;// &#26041;&#27861;&#20116;&#10;+ (CoreTextData *)parseAttributedContent:(NSAttributedString *)content config:(CTFrameParserConfig*)config &#123;&#10;    // &#21019;&#24314; CTFramesetterRef &#23454;&#20363;&#10;    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)content);&#10;&#10;    // &#33719;&#24471;&#35201;&#32531;&#21046;&#30340;&#21306;&#22495;&#30340;&#39640;&#24230;&#10;    CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX);&#10;    CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil);&#10;    CGFloat textHeight = coreTextSize.height;&#10;&#10;    // &#29983;&#25104; CTFrameRef &#23454;&#20363;&#10;    CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight];&#10;&#10;    // &#23558;&#29983;&#25104;&#22909;&#30340; CTFrameRef &#23454;&#20363;&#21644;&#35745;&#31639;&#22909;&#30340;&#32531;&#21046;&#39640;&#24230;&#20445;&#23384;&#21040; CoreTextData &#23454;&#20363;&#20013;&#65292;&#26368;&#21518;&#36820;&#22238; CoreTextData &#23454;&#20363;&#10;    CoreTextData *data = [[CoreTextData alloc] init];&#10;    data.ctFrame = frame;&#10;    data.height = textHeight;&#10;&#10;    // &#37322;&#25918;&#20869;&#23384;&#10;    CFRelease(frame);&#10;    CFRelease(framesetter);&#10;    return data;&#10;&#125;&#10;&#10;// &#26041;&#27861;&#20845;&#10;+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter&#10;                                  config:(CTFrameParserConfig *)config&#10;                                  height:(CGFloat)height &#123;&#10;&#10;    CGMutablePathRef path = CGPathCreateMutable();&#10;    CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height));&#10;&#10;    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);&#10;    CFRelease(path);&#10;    return frame;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要由 6 个子方法构成：</p>
<ul>
<li>方法一用于提供对外的接口，调用方法二实现从一个 JSON 的模版文件中读取内容，然后调用方法五生成<code>CoreTextData</code>。</li>
<li>方法二读取 JSON 文件内容，并且调用方法三获得从<code>NSDictionary</code>到<code>NSAttributedString</code>的转换结果。</li>
<li>方法三将<code>NSDictionary</code>内容转换为<code>NSAttributedString</code>。</li>
<li>方法四提供将<code>NSString</code>转为<code>UIColor</code>的功能。</li>
<li>方法五接受一个<code>NSAttributedString</code>和一个<code>config</code>参数，将<code>NSAttributedString</code>转换成<code>CoreTextData</code>返回。</li>
<li>方法六是方法五的一个辅助函数，供方法五调用。</li>
</ul>
<p>然后我们将<code>ViewController</code>中的调用代码作一下更改，使其从模版文件中加载内容，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;@implementation ViewController&#10;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];&#10;    config.width = self.ctView.width;&#10;    NSString *path = [[NSBundle mainBundle] pathForResource:@&#34;content&#34; ofType:@&#34;json&#34;];&#10;    CoreTextData *data = [CTFrameParser parseTemplateFile:path config:config];&#10;    self.ctView.data = data;&#10;    self.ctView.height = data.height;&#10;    self.ctView.backgroundColor = [UIColor whiteColor];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p>最后运行得到的结果如下所示，可以看到，通过一个简单的模板文件，我们已经可以很方便地定义排版的配置信息了。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-load-from-json-template.png" alt=""></p>
<p>说明：读者可以在示例工程中使用<code>git checkout json_template</code>，查看可以运行的示例代码。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://blog.devtang.com/2015/06/27/using-coretext-1/" data-title="基于 CoreText 的排版引擎：基础 | 唐巧的博客" data-tsina="undefined" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/06/27/using-coretext-2/" title="基于 CoreText 的排版引擎：进阶">
  <strong>上一篇：</strong><br/>
  <span>
  基于 CoreText 的排版引擎：进阶</span>
</a>
</div>


<div class="next">
<a href="/2015/06/16/talk-about-tech-interview/"  title="你会翻转二叉树吗？--谈程序员的招聘">
 <strong>下一篇：</strong><br/> 
 <span>你会翻转二叉树吗？--谈程序员的招聘
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/06/27/using-coretext-1/" data-title="基于 CoreText 的排版引擎：基础" data-url="http://blog.devtang.com/2015/06/27/using-coretext-1/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  <div class="sponsor">
  <br />
  <p class="asidetitle">广告</p>
  <a target="_blank" href="https://jianxun.io/?utm_source=ad&utm_medium=site_ad&utm_compaign=tangqiao&utm_content=pos_right&utm_term=jialezhang">
  <img src="https://jianxun.io/gg/201607/tangqiao/235x200.jpg" width="235px" height="200px" />
  </a>
  <br />
  <br />
  <a target="_blank" href="http://gold.xitu.io/extension/?utm_source=tangqiao&utm_medium=banner&utm_content=juhe&utm_campaign=q3_extension">
  <img src="http://ww1.sinaimg.cn/large/65dc76a3gw1f7eflvezerj206j05kglt.jpg" width="235px" height="200px" />
  </a>
  <br />
  <br />
  <a target="_blank" href="https://www.julyedu.com/course/getDetail/49" title="七月在线" >
  <img src="http://ww4.sinaimg.cn/mw690/65dc76a3jw1f9d0pdtytrj206j02st9y.jpg" width="235px" height="100px" />
  </a>
  <br /><br /><a href="/sponsor">
  <font color="#2ca6cb" style="
    font-size: 14px;
    text-align: right;
">购买广告位</font></a>
</div>


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/books-summary/" title="books summary">books summary</a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS</a></li>
		  
		
		  
			<li><a href="/categories/iOS-weekly/" title="iOS weekly">iOS weekly</a></li>
		  
		
		  
			<li><a href="/categories/mac/" title="mac">mac</a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell</a></li>
		  
		
		  
			<li><a href="/categories/summary/" title="summary">summary</a></li>
		  
		
		  
		
		  
		
		</ul>
</div>


  <div class="weixin">
  <br />
  <p class="asidetitle">微信公众号</p>
  <p>关注唐巧的「iOS开发」公众号，获得精选的 iOS 开发文章和创业心得：</p>
  <img src="http://ww4.sinaimg.cn/mw690/65dc76a3jw1f1ngaau9arj20760763yr.jpg" width="230px" />

</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

	<p class="copyright" style="margin-top: 10px;">
	Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016
	
	<a href="/about" target="_blank" title="唐巧">唐巧</a>
	

	</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"tangqiaoboy"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 









<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-28029597-1', 'null');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
