<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[唐巧的技术博客]]></title>
  <subtitle><![CDATA[记录下自己学习的点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2016-12-03T14:42:05.000Z</updated>
  <id>http://blog.devtang.com/</id>
  
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[流利说「懂你英语」体验报告]]></title>
    <link href="http://blog.devtang.com/2016/12/03/liulishuo-dongni-english-summary/"/>
    <id>http://blog.devtang.com/2016/12/03/liulishuo-dongni-english-summary/</id>
    <published>2016-12-03T14:42:05.000Z</published>
    <updated>2016-12-03T14:42:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><p>最近报了流利说的 99 元一个月的「懂你英语」，之后又续了一个月，简单写一下体验报告。事先申明，这不是一个软文。</p>
<h2 id="u4EC0_u4E48_u662F_u6D41_u5229_u8BF4_u7684_u300C_u61C2_u4F60_u82F1_u8BED_u300D"><a href="#u4EC0_u4E48_u662F_u6D41_u5229_u8BF4_u7684_u300C_u61C2_u4F60_u82F1_u8BED_u300D" class="headerlink" title="什么是流利说的「懂你英语」"></a>什么是流利说的「懂你英语」</h2><p>「懂你英语」试图用最简单的、婴儿学语言的方式来学习英语，即：先盲听，即看不到什么单词，只有一张图片提示你说的内容。然后，你需要重复听和跟读，每次跟读时，可以判断跟读内容是否合格，如果合格，则会有 +1 的提示。</p>
<p>「懂你英语」是一种比较挣钱的商业模式，因为它完全依赖于机器来判分（而且是用户的手机），服务器只需要提供学习资源的下载服务即可，所以它的毛利率可以做到很高，我估计毛利率到 70% 是没问题的。</p>
<p>另外，「懂你英语」的产品设计是非常适合学习者的。因为它将学习任务进行了卡片式的任务拆解，所以你只需要关注于每天的任务完成就可以了。「懂你英语」要求每天练习口语 30 分钟，它在产品设计中通过每日学习统计，打卡，班主任督学，班级学习时长排名，学习效率分等各种细节来促使你坚持完成每天的学习任务。</p>
<p>这种任务式、关卡式的产品设计方案已经在很多产品设计中被采用，除了流利说外，像 Keep，洋葱数学也是这样。这样的设计使得大家能够专注于眼前的小任务，然后通过达成每一个小任务获得成熟感和激励，最终完成一个大的目标。</p>
<p>我现在认为，所有需要长久的学习任务，都应该拆分成小的阶段，以小任务的方式来完成。这就像我们工作的时候采用 Scrum，每个 Story 又拆分成一个个小的 Task 一样，让自己的工作即清晰，又可以在半天内完成。番茄钟的工作方式也是这样，将任务拆成若干个 45 分钟。产品的版本迭代也是这样，每个版本都有一个大的 Milestone，好的产品路线图既让人感觉目标清晰，又让人觉得目标可以达成。</p>
<h2 id="u300C_u61C2_u4F60_u82F1_u8BED_u300D_u9644_u52A0_u7684_u300C_u670D_u52A1_u300D"><a href="#u300C_u61C2_u4F60_u82F1_u8BED_u300D_u9644_u52A0_u7684_u300C_u670D_u52A1_u300D" class="headerlink" title="「懂你英语」附加的「服务」"></a>「懂你英语」附加的「服务」</h2><p>「懂你英语」比较好地做到了「服务」感，我个人认为这个是当前在线教育比较缺少的地方，这方面「懂你英语」值得被学习。说说我的体验吧：</p>
<ul>
<li>我报完名之后，App 会显示一个微信号，可以复制之后，关注公众号。</li>
<li>然后公众号进去之后，回复自己的帐号，可以获得班级群信息。</li>
<li>在班级群里面，班主任会主动和你沟通，帮你解答学习中的各种问题。</li>
<li>每天中午和晚上，班主任会发一条作业，很多时候是邀请大家一起来做，对于做了的同学，班主任会在群里解答。</li>
<li>每个周末，班主任会策划一个学习活动，有一些活动是小组活动，需要大家一起完成。</li>
<li>每天会有学习排行榜在群里，告诉大家哪些人学了，哪些人没学。</li>
<li>对于没有学习的人，班主任会在微信里面单独留言了解为什么没学。</li>
<li>班级快要结束的时候，班主任会一一私聊，问是否需要续费，并且介绍续费优惠活动。</li>
</ul>
<p>我从这个学习当中获得了：</p>
<p> 1、被老师服务的感觉<br> 2、一起学习的感觉（集体）<br> 3、竞争的感觉（排名）<br> 4、感情（同学，老师）</p>
<p>这些都使得我觉得「懂你英语」不是一个冷冰冰的机器服务，值得花 99 元来报名。</p>
<h2 id="u300C_u61C2_u4F60_u82F1_u8BED_u300D_u7684_u95EE_u9898"><a href="#u300C_u61C2_u4F60_u82F1_u8BED_u300D_u7684_u95EE_u9898" class="headerlink" title="「懂你英语」的问题"></a>「懂你英语」的问题</h2><p>夸完了「懂你英语」，再说说一些问题。这个课程依赖了两个很强的假设，但我认为这两者都还处于发展（或者不确定中）：</p>
<ul>
<li><p>假设一：成人像婴儿那样学语言，是更好的方式么？「懂你英语」称这个研究来自国外的某个教授，我没有深入查证。但是就我个人体验来说，明明知道一句话说的什么，但是完全无法知道这个单词如何拼写还是非常难受的。最终，一些用户甚至拿另一个手机打开 Google 的听写功能，用于识别这些内容的拼写。按理说，学完检测应该是一个很好的判断自己是否提高的方式，但是「懂你英语」考试的内容其实就是练习的内容，所以你也无从判断是因为自己熟悉这些内容说得好，还是自己真正口语得到提高了。</p>
</li>
<li><p>假设二：机器能够很好地判断发音是否正确。现在深度学习如火如荼，流利说做到了完全在本地就可以用人工智能算法判断发音是否准确，但是就我个人的体验来说，机器对于较短的单词发音过于严格，例如：<code>are</code>, <code>is</code>, <code>it</code>, <code>there</code>, <code>with</code> 这些单词，常常会显示成黑色（读得不好），而一些长的单词，比如 <code>comfortable</code>, <code>birthday</code>, 即使读得自己都感到有些错了，但是机器有时会显示成绿色（读得好）。我问了一下我们公司（猿辅导）的首席科学家邓博，他说这些简单的单词因为标注数据多，所以做得比较精确，而那些长的单词，因为标注数据要做多的话工作量很大，所以只能降低召回率，以便保证召回数据的正确率。</p>
</li>
</ul>
<p>但是这些问题其实都还好，因为口语练习最重要的就是说，即便你它判分不准，只要你天天坚持说 30 分钟，还是有效果的。</p>
<p>我之所以后来没有继续学，其实是因为「懂你英语」在通关的设计上，加了很多不合理地设计。比如到达 Level 4 之后，很多关卡的通关，依赖的是你背下前面的课程。我还记得 Level 4 的第二张卡片中的一个关卡，要求将文章的内容进行排序，除非你反复学习背下文章内容，否则是无法通关的。但是这其实并不能锻炼口语能力，只能练习记忆力。所以这让我感觉这个课程学习起来效率有些低下。类似的记忆考试挺多，有些考试直接就问：<code>How long did he stay in China? When did he graduated?</code> 这些都需要背。对于追求效率的我来说，我觉得背下课文通关没有意义，我需要的是练习口语，而不是熟悉并背下课文。即使要背下课文，我也希望是以高效地方式来背，而不是通过只听不看的方式来背诵。</p>
<p>最后，整个 App 的 Bug 还是挺多的，一些 Bug 让我甚至感觉到产品功能没有被仔细使用过，因为细心使用的话，明显就能体会到。不过相对于上面的产品问题，这些问题还不至于致命。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>就我个人感觉，「懂你英语」是一个差一点就成功的产品，很多地方可圈可点，它让我看到了未来在线教育产品的雏形。</p>
<p>如果未来它能够改进关卡设计上再进行打磨，同时机器在判断读音准确性上能够有再进一步的提升，那么确实有可能成为一个不错的语言自学服务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><p>最近报了流利说的 99 元一个月的「懂你英语」，之后又续了一个月，简单写一下体验报告。事先申明，这不是一个软文。</p>
<h2 i]]>
    </summary>
    
      <category term="PM" scheme="http://blog.devtang.com/tags/PM/"/>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[信息的迷失]]></title>
    <link href="http://blog.devtang.com/2016/12/03/talk-about-information-explosion/"/>
    <id>http://blog.devtang.com/2016/12/03/talk-about-information-explosion/</id>
    <published>2016-12-03T14:41:46.000Z</published>
    <updated>2016-12-03T14:41:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4FE1_u606F_u7684_u7206_u70B8"><a href="#u4FE1_u606F_u7684_u7206_u70B8" class="headerlink" title="信息的爆炸"></a>信息的爆炸</h2><p>还记得我读小学的时候，那个时候还没有互联网，所有人获取信息的渠道都来自传统的媒介：图书、报纸、广播、电视。那个时候，我无聊的时候可以把一本书反复翻，反复看，因为并没有什么别的书可以看。电视的普及应该是第一次将人们获取信息的能力进行了放大，电视除了让人们获取新闻之类的信息外，更多的是使得人们从中获得娱乐信息，即娱乐的方式从传统的纸媒和广播，变成了多媒体视频，进而产生了一个巨大的娱乐产业。</p>
<p>互联网的产生，除了让信息的获取成本变得极为容易外，同时也让信息经历了再一次的爆炸。由于信息实在太多了，所以有了搜索引擎，帮助我们检索需要的信息。另外，wikipedia、大学的 Mooc 视频，让大量优质的内容获得也变得极为容易。</p>
<h2 id="u4FE1_u606F_u7684_u89E6_u624B_u53EF_u5F97"><a href="#u4FE1_u606F_u7684_u89E6_u624B_u53EF_u5F97" class="headerlink" title="信息的触手可得"></a>信息的触手可得</h2><p>以前我们要接入互联网获得信息，我们通常需要打开电脑，这本身就是一个昂贵的成本。现在由于智能手机的普及，接入互联网变得极为容易，我们甚至不需要解锁输入密码或指纹，在手机的锁屏界面上就可以获得大量的信息。</p>
<p>移动互联网真正牛逼的地方就在于它改变了互联网的接入方式，它让每一个人都能做到随时在线，所以，10 年前的 QQ 有在线和离线的状态，而现在的微信则没有，所有人都始终是在线的。</p>
<h2 id="u4FE1_u606F_u7684_u8FF7_u5931"><a href="#u4FE1_u606F_u7684_u8FF7_u5931" class="headerlink" title="信息的迷失"></a>信息的迷失</h2><p>可是问题是：没有人能够消费完这么多的信息。我们有一款初高中生的题库 App：猿题库，到现在为止我们收录了百万级的题目，没有人能够做得完这么多题目。所以我们提供了智能的推荐算法，帮助学生找到最适合他练习的题目。</p>
<p>信息检索和推荐算法，某种程度上解决了海量信息的获取问题，但是却解决不了注意力被分散的问题。</p>
<p>让我们看看这个场景：某一天你 6 点钟回到家，打算做一件事情，突然你手机收到一条 Push，其实是一条网易新闻的推送，新闻的标题很吸引人，于是你打开了。看完这条新闻，你不自觉地又看起来别的新闻。看完新闻后，你又不自觉地打开微信，翻朋友圈的消息，给好友点赞，点完一圈赞后，你又打开微信订阅号，查看订阅的一些文章。等你突然觉得困了，你才发现本来要做的事情完全忘记掉了！</p>
<p>基本上，那些用于你打发碎片时间的应用，不但把你的碎片时间打发了，而且把你的主要时间也打发掉了。</p>
<p>是的，大部分在信息面前迷失掉了，我的母校北京师范大学心理学系曾经专门有人研究过人们在电脑和手机上注意力的转移，大部分人只要稍不加控制，大脑的注意力就轻易地被各种红点，通知提醒，QQ 消息或者浮窗广告吸引了。</p>
<h2 id="u4FE1_u606F_u7684_u5C4F_u853D"><a href="#u4FE1_u606F_u7684_u5C4F_u853D" class="headerlink" title="信息的屏蔽"></a>信息的屏蔽</h2><p>总会有一天，大家都会意识到信息太多也是问题，然后会学会屏蔽信息。</p>
<p>我发现的最简单的屏蔽信息的办法是将自己当天的 Todo List 写在一张小小的便签纸上，然后贴在屏幕的一角，做完一件事情则划掉进行下一项。如果因为各种原因（电话，短信，别人的打扰）而中断，我就可以通过这张小小的纸片找回自己的目标。</p>
<p>当然，我们也可以用更复杂的办法，例如使用番茄工作法，或者 GTD 中提到的任务处理方式，来使得自己更加容易专注地处理信息和任务。</p>
<p>大家太依赖手机了，甚至离开手机太久都会不舒服。不知道大家有没有试过将手机关机一整天？我相信你会感受到你就像被世界屏蔽了，失去了和整个世界的连接。但是其实，人们总是需要一些长时间的思考的，或许是解决工作上的问题，或许是个人的一些规划，或许是思考未来，这些时候，断开和世界的连接反倒是好的。</p>
<p>乔布斯在他的自传中提到他年轻的时候很喜欢禅修，在我看来，这其实就是一种放空大脑，让自己专注于思考的一种体验。一旦人们体验到专注思考的好处，就不会那么依赖网络了。</p>
<h2 id="u81EA_u5A92_u4F53_u7684_u5D1B_u8D77_u548C_u8870_u843D"><a href="#u81EA_u5A92_u4F53_u7684_u5D1B_u8D77_u548C_u8870_u843D" class="headerlink" title="自媒体的崛起和衰落"></a>自媒体的崛起和衰落</h2><p>在传统的年代，明星出名都是需要依赖传统媒体的，或许是报纸，或许是电视，而这些渠道有着极强的控制力，所以可以轻易对明星进行封杀或捧星。但是，互联网的出现，使得信息传播的渠道变得不但多样化而且免费，像新浪微博，微信公众号，知乎，一些论坛，都成为大 V 极好的成名渠道，而且这些大 V 的成名，基本上完全依赖于他们自己的本身的能力，靠本事吃饭，与渠道无关。</p>
<p>于是，这成为了自媒体人最好的年代，优质的内容可以在极短的时间内传播开来，帮助大 V 获得粉丝和影响力。</p>
<p>但是，人们的注意力终究是有限的，在早期的少量自媒体人享受到渠道开放的红利之后，由于信息的爆炸，更多的优秀内容反倒是被埋没在信息的汪洋之中。后期的自媒体人要获得足够的注意力，需要在内容质量上花费更多的心血。大部分无法创建出极度优秀的内容的自媒体人，在这样的年代完全没有了翻身的机会。</p>
<h2 id="u6E20_u9053_u7684_u518D_u6B21_u5D1B_u8D77"><a href="#u6E20_u9053_u7684_u518D_u6B21_u5D1B_u8D77" class="headerlink" title="渠道的再次崛起"></a>渠道的再次崛起</h2><p>信息的爆炸，自媒体的涌现，使得人们再一次需要一种内容筛选的服务，即便这种服务是付费的。于是我们看到，一些基于优质内容的付费服务再次得到人们地青睐，比如”得到“App，比如知乎Live，各种收费直播服务。这些付费服务的成功原因有很多：被服务感、直播的参与感与真实感，但不可否认，对于优质内容的价值认可，以及在海量信息中选择的无助，也是这些服务被认可的基础。</p>
<h2 id="u672A_u6765"><a href="#u672A_u6765" class="headerlink" title="未来"></a>未来</h2><p>未来的信息消费是更趋于集中还是分散，我没有定论。不过未来相比信息本身的价格，人们的时间成本会变得更加重要，因为每一个人的时间都是稀缺资源，没有人愿意拿自己的生命来「试错」。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4FE1_u606F_u7684_u7206_u70B8"><a href="#u4FE1_u606F_u7684_u7206_u70B8" class="headerlink" title="信息的爆炸"></a>信息的爆炸</h2><p>还记得我读小学的时候]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 移动开发周报 - 第 48 期]]></title>
    <link href="http://blog.devtang.com/2016/11/01/ios-weekly-48/"/>
    <id>http://blog.devtang.com/2016/11/01/ios-weekly-48/</id>
    <published>2016-11-01T15:26:06.000Z</published>
    <updated>2016-11-01T15:45:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u65B0_u95FB"><a href="#u65B0_u95FB" class="headerlink" title="新闻"></a>新闻</h2><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><p>由于众所周知的原因，国内并不能访问到官方的 Ruby 源，所以大部分朋友可能都是使用的国内的镜像源。而这里面，使用的最多的，可能就是淘宝提供的镜像源了。不过最近淘宝的镜像源 ruby.taobao.org 停止更新了，所以使用 CocoaPods 的同学，请更新到 ruby china 的源。详细的内容，请参见：<a href="https://ruby-china.org/topics/29250" target="_blank" rel="external">https://ruby-china.org/topics/29250</a>。</p>
<p>另一方面 , CocoaPods 最近也升级到了 <a href="http://blog.cocoapods.org/CocoaPods-1.1.0/" target="_blank" rel="external">1.1.0 版本</a>，主要是增加了对 Xcode 8 的支持。</p>
<h3 id="u82F9_u679C_u53D1_u5E03_u4F1A"><a href="#u82F9_u679C_u53D1_u5E03_u4F1A" class="headerlink" title="苹果发布会"></a>苹果发布会</h3><p>苹果在不久前发布了新款 <a href="https://36kr.com/p/5055335.html" target="_blank" rel="external">MacBook Pro</a>，库克对 Vim 党痛下杀手，取消了 ESC 键。另外增加了酷炫的 Touch Bar。有小伙伴已经尝试了 Touch Bar 对外的编程接口，说是和 「watchOS 很像」。一向前位的苹果也取消了包括 USB 在内的众多接口，只保留了 Thunderbolt 3 接口。</p>
<h3 id="Swift_Server_Api"><a href="#Swift_Server_Api" class="headerlink" title="Swift Server Api"></a>Swift Server Api</h3><p>苹果在 Swift 官方网站上新建了一个基于 Swift 的 <a href="https://swift.org/server-apis/" target="_blank" rel="external">API 项目</a>，该项目用于支持将 Swift 用于服务器端开发的基础设施的构建。</p>
<h3 id="UniBeast"><a href="#UniBeast" class="headerlink" title="UniBeast"></a>UniBeast</h3><p><a href="https://www.tonymacx86.com/threads/unibeast-install-macos-sierra-on-any-supported-intel-based-pc.200564/" target="_blank" rel="external">UniBeast</a> 是一个能够将 macOS Sierra 安装到任何基于 Intel CPU 的电脑上。</p>
<h2 id="u6587_u7AE0"><a href="#u6587_u7AE0" class="headerlink" title="文章"></a>文章</h2><ul>
<li><p><a href="http://www.zoomfeng.com/blog/ipa-size-thin.html" target="_blank" rel="external">《iOS 安装包瘦身指南》</a>： 本文介绍了包括资源优化，编译选项优化，可执行文件优化等 IPA 文件的瘦身方法。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/f792f9aa2e45" target="_blank" rel="external">《Xcode8调试黑科技：Memory Graph实战解决闭包引用循环问题》</a>：Xcode8 的调试技能又增加了一个黑科技：Memory Graph。简单的说就是可以在运行时将内存中的对象生成一张图，这样检查循环引用问题将更加方便。</p>
</li>
</ul>
<h2 id="u6709_u8DA3"><a href="#u6709_u8DA3" class="headerlink" title="有趣"></a>有趣</h2><p>本周趣图，是苹果公司在 2008 年生产的一款黑色 MacBook，看久了银白色的 MacBook 的你，是否感到耳目一新？</p>
<p><img src="http://ww1.sinaimg.cn/large/65dc76a3jw1f9d0wslzigj20lu0czwgn.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u65B0_u95FB"><a href="#u65B0_u95FB" class="headerlink" title="新闻"></a>新闻</h2><h3 id="CocoaPods"><a href="#CocoaPods" class="headerli]]>
    </summary>
    
      <category term="iOS weekly" scheme="http://blog.devtang.com/categories/iOS-weekly/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 移动开发周报 - 第 47 期]]></title>
    <link href="http://blog.devtang.com/2016/10/16/ios-weekly-47/"/>
    <id>http://blog.devtang.com/2016/10/16/ios-weekly-47/</id>
    <published>2016-10-16T15:34:22.000Z</published>
    <updated>2016-10-16T14:52:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u65B0_u95FB"><a href="#u65B0_u95FB" class="headerlink" title="新闻"></a>新闻</h2><h3 id="u82F9_u679C_u89E3_u91CA_Dash__u4E0B_u67B6_u7684_u539F_u56E0"><a href="#u82F9_u679C_u89E3_u91CA_Dash__u4E0B_u67B6_u7684_u539F_u56E0" class="headerlink" title="苹果解释 Dash 下架的原因"></a>苹果解释 Dash 下架的原因</h3><p>上周关于 Dash 被苹果下架的事情有了来自 <a href="http://www.loopinsight.com/2016/10/10/apple-responds-to-dash-controversy-with-proof/" target="_blank" rel="external">苹果的解释</a>，苹果说 Dash 进行了刷榜，具体来说，是在 Dash 的评价中发现了一些明显带有欺骗性的评分。苹果同时说这个决定是最终的，并且不可申述（final and can’t be appealed），所以这件事情可能最终的结果就是这样了。</p>
<p>我们从这件事情中可以看出，苹果对于刷榜的行为变得越来越严厉了。但是在国内，刷榜的行为还是普遍存在，而且大多数都没有受到惩罚。例如，我们公司的三款产品都没有刷榜，但是我们的竞争对手其实都有明显的刷榜行为。希望苹果能够有机会也整治一下国内的环境，让大家都在一个公平的环境中竞争。</p>
<h3 id="Swift_4"><a href="#Swift_4" class="headerlink" title="Swift 4"></a>Swift 4</h3><p>是的，Swift 4 开始开发了，在 Swift 4 在 GitHub 的主页上，苹果公布了 Swift 4 的 <a href="https://github.com/apple/swift-evolution/blob/master/README.md#development-major-version--swift-40" target="_blank" rel="external">主要目标</a>。时间上，苹果计划在 2017 年晚些时候正式发布 Swift 4。苹果希望将 Swift 4 的开发分为两个阶段：</p>
<ul>
<li>第一阶段：关注于核心的一些需求，以及 ABI 的稳定性。苹果不希望在 Swift 4 中引入 ABI-breaking 的改变。</li>
<li>第二阶段：该阶段希望在 2017 年春能够开始讨论，在第一阶段的任务完成后，可以增加一些或大或小的新特性。</li>
</ul>
<h3 id="iDev__u5927_u4F1A"><a href="#iDev__u5927_u4F1A" class="headerlink" title="iDev 大会"></a>iDev 大会</h3><p>​<a href="http://www.bagevent.com/event/207773" target="_blank" rel="external">iDev 大会</a>是一场由开发者自己办的技术会议，会议内容主要面向苹果的开发者，我是这次会议的出品人。</p>
<p>今年 iOS 的话题其实集中在 Swift 语言、函数式编程、跨平台方案，所以这方面的话题本次大会都有涉及。另外 iOS 安全一直是被人们较为忽视的一个方面，本次大会我在这方面也特别有设计议题讨论。</p>
<p>考虑到 iDev 大会希望涉及苹果全平台的技术，所以本次大会我们也安排了关于 macOS、watchOS 和 HomeKit 的议题。</p>
<p>对了，购票时输入我的优惠码：tangqiao，可以获得折扣票价再打 85 折哟。你也可直接访问以下网址获得优惠过的价格：<br><a href="http://www.bagevent.com/event/207773?discountCode=tangqiao" target="_blank" rel="external">http://www.bagevent.com/event/207773?discountCode=tangqiao</a></p>
<h2 id="u6587_u7AE0"><a href="#u6587_u7AE0" class="headerlink" title="文章"></a>文章</h2><h3 id="u95ED_u5305_u7684_escaping__u4E0E_non-escaping"><a href="#u95ED_u5305_u7684_escaping__u4E0E_non-escaping" class="headerlink" title="闭包的 escaping 与 non-escaping"></a>闭包的 escaping 与 non-escaping</h3><p><a href="https://oleb.net/blog/2016/10/optional-non-escaping-closures/" target="_blank" rel="external">Optional Non-Escaping Closures</a>： 本文讨论了 Swift 中的闭包的 escaping 的情况。所谓 escaping，就是指闭包在作为参数，传递给相应函数之后，相应函数执行完成了，但是闭包可能还需要被调用。所以，这个闭包似乎是逃离（escaping）了函数的作用时间。因为按理说函数执行完了，相应的参数应该就没用了，但是对于 escaping 的闭包，却不是这样。</p>
<p>什么情况下会出现这种情况呢？最常见的场景就是异步调用。比如我们发起一个网络请求，传入了一个闭包作为回调参数。这个闭包显然需要在网络请求结束时，才会被调用，这就是一个 escaping 的闭包。类似的还包括：我们把一些闭包放到 GCD 提供的 Dispatch Queue 中，也会造成 escaping 的闭包。</p>
<p>在本文中，作者讨论了一种比较特别的现象：只要一个闭包是 Optional 的，则它一定会是一个 escaping 的闭包。作者讨论了产生此问题的原因，并且提供了一些解决方案。</p>
<h3 id="u628A_u7B2C_u4E09_u65B9_iOS__u5E94_u7528_u8F6C_u6210_u52A8_u6001_u5E93"><a href="#u628A_u7B2C_u4E09_u65B9_iOS__u5E94_u7528_u8F6C_u6210_u52A8_u6001_u5E93" class="headerlink" title="把第三方 iOS 应用转成动态库"></a>把第三方 iOS 应用转成动态库</h3><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=2709545228&amp;idx=1&amp;sn=7a47a0de32e06f9c465319e8db8ca13f&amp;chksm=828f0bd2b5f882c46416ab20cd9ea482b3c57b202d876b75d5625a1bb036d40fe01d31c2679a&amp;mpshare=1&amp;scene=1&amp;srcid=1009N6R6XQyc1MDWhh0MfG7h#rd" target="_blank" rel="external">《黑科技：把第三方 iOS 应用转成动态库》</a>，本文介绍了一个自己写的工具，能够把第三方 iOS 应用转成动态库，并加载到自己的 App 中，文章最后会以支付宝为例，展示如何调用其中的 C 函数和 OC 方法。另外，本文首发在我的微信公众号：iOSDevTips 中，如果你还没有关注过，请扫码关注哟：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/65dc76a3jw1f1ngaau9arj20760763yr.jpg" alt=""></p>
<h2 id="u89C6_u9891"><a href="#u89C6_u9891" class="headerlink" title="视频"></a>视频</h2><p>本周视频推荐 objc.io 出的一期视频：<a href="https://talk.objc.io/episodes/S01E15-building-parser-combinators-part-1" target="_blank" rel="external">手写一个 Parser</a>。</p>
<h2 id="u5DE5_u5177"><a href="#u5DE5_u5177" class="headerlink" title="工具"></a>工具</h2><p>本周推荐的工具，是一个 Xcode 8 的效率工具。它可以方便你在任何时候输入需要 import 的内容。其实这类工具在别的平台都是 IDE 自动提供的，以前我在用 Eclipse 写后台的时候，用了一个需要 import 的库的类，只需要按 cmd + shift + o，IDE 就会自动把这些需要 import 的头文件帮你填上，以节省时间。Xcode 在这方面，还有挺多需要加强的。Anyway，Xcode 的 extension 这个机制也让我们能够自己动手丰衣足食了。</p>
<p>该工具在 GitHub 上的地址是 <a href="https://github.com/markohlebar/Import" target="_blank" rel="external">Import</a>，以下是使用起来的效果动画：</p>
<p><img src="https://raw.githubusercontent.com/markohlebar/Import/master/Resources/usage.gif" alt=""></p>
<h2 id="u6709_u8DA3"><a href="#u6709_u8DA3" class="headerlink" title="有趣"></a>有趣</h2><p>本周的趣图来自 <a href="http://weibo.com/lexrus?from=feed&amp;loc=nickname" target="_blank" rel="external">汤圣罡</a>，由苹果的各种配件组成的一个笑脸，愿大家都有一个愉快的一天。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/68212547jw1f87dsllmyzj20u00u0q4h.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u65B0_u95FB"><a href="#u65B0_u95FB" class="headerlink" title="新闻"></a>新闻</h2><h3 id="u82F9_u679C_u89E3_u91CA_Dash__u4E0B_u67B6_u7684]]>
    </summary>
    
      <category term="iOS weekly" scheme="http://blog.devtang.com/categories/iOS-weekly/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 移动开发周报 - 第 46 期]]></title>
    <link href="http://blog.devtang.com/2016/10/10/ios-weekly-46/"/>
    <id>http://blog.devtang.com/2016/10/10/ios-weekly-46/</id>
    <published>2016-10-10T13:08:08.000Z</published>
    <updated>2016-10-10T12:43:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>大家国庆节过得如何？我反正是整个人的作息都变了，估计要调整过来得花不少时间。</p>
<p>国庆节期间开车还经历了人生第一次剐蹭，倒车时方向盘转得过猛，车头把停在旁边的一台宝马 5 系给蹭到了，吓得我赶紧报了保险。结果最后定损的维修费用也就几百块钱，用交强险就 cover 住所有费用了。人生就是不停地经历，有了这次出险，以后估计开车会更加小心。</p>
<p>好了，言归正传，我们来看看本周的 iOS 新闻。</p>
<h2 id="u65B0_u95FB"><a href="#u65B0_u95FB" class="headerlink" title="新闻"></a>新闻</h2><h3 id="Search_Ads__u4E0A_u7EBF"><a href="#Search_Ads__u4E0A_u7EBF" class="headerlink" title="Search Ads 上线"></a>Search Ads 上线</h3><p>苹果的 AppStore 搜索广告终于 <a href="https://developer.apple.com/news/?id=09282016a" target="_blank" rel="external">正式上线了</a>，不过现在仅支持 iPhone 平台和美国区。AppStore 搜索广告类似于百度搜索关健词的竞价排名机制，该平台未来在中国区上线之后，我估计会使得一部分刷榜行为转移到正常的广告投放上。另外各个公司其实也需要及时介入，对自己的商标或产品关键词进行提前保护，以避免被恶意投放广告。关于 Search Ads 的详细介绍，今年的 WWDC 有<a href="https://developer.apple.com/videos/play/wwdc2016/302/" target="_blank" rel="external">专门的介绍视频</a>，建议大家都看看。</p>
<h3 id="Dash__u88AB_AppStore__u4E0B_u67B6"><a href="#Dash__u88AB_AppStore__u4E0B_u67B6" class="headerlink" title="Dash 被 AppStore 下架"></a>Dash 被 AppStore 下架</h3><p>Dash 是一款优秀的 Mac 效率工具，恰当的使用它，可以极大地提高你的输入速度。最近，作者被 Apple 告知其帐户「因涉嫌诈欺」而被停权。作者提供了授权迁移工具，便于大家将授权转移出来。详情：<a href="https://zhuanlan.zhihu.com/p/22782111" target="_blank" rel="external">阅读原文</a>。</p>
<p>关于 Dash 被下架的原因，大家众说纷纭，其中有一个说法是：Dash 在将其的个人帐户转成企业帐户时，涉及的邓白氏码（DUNS）的代理公司可能提供的信息有问题，牵连了 Dash。</p>
<h3 id="u6625_u96E8_u533B_u751F_u521B_u59CB_u4EBA_u5F20_u9510_u53BB_u4E16"><a href="#u6625_u96E8_u533B_u751F_u521B_u59CB_u4EBA_u5F20_u9510_u53BB_u4E16" class="headerlink" title="春雨医生创始人张锐去世"></a>春雨医生创始人张锐去世</h3><p>我和张锐有过在网易门户的短暂共事经历，不曾想到张锐正值创业上升时期 <a href="http://politics.caijing.com.cn/20161006/4183250.shtml" target="_blank" rel="external">离世</a>，令人唏嘘不已。国内互联网公司虽然有着远高于别的行业的平均薪水，但是也同时伴随着极高的工作强度，不管是创业公司，还是已经上市的 BAT，加班就犹如家常便饭。但是，身体总归还是我们自己的，希望大家都能平衡好事业和身体。</p>
<h2 id="u6587_u7AE0"><a href="#u6587_u7AE0" class="headerlink" title="文章"></a>文章</h2><h3 id="Swift_3"><a href="#Swift_3" class="headerlink" title="Swift 3"></a>Swift 3</h3><p>Swift 3 的迁移工作并不轻松，喵神说他的开源库 <a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="external">Kingfisher</a> 大概花了 200 个提交，才完成了迁移工作。</p>
<p>最近，Glow 技术团队分享了 Swift 3 带来的改变，感兴趣的可以<a href="http://tech.glowing.com/cn/swift3/" target="_blank" rel="external">点这里阅读</a>。</p>
<p>国庆前，图拉鼎也分享了适配 Swift 3 的一点小经验和坑，<a href="https://imtx.me/archives/2064.html" target="_blank" rel="external">点这里阅读</a>。</p>
<h3 id="Let_u2019s_Talk_About_project-pbxproj"><a href="#Let_u2019s_Talk_About_project-pbxproj" class="headerlink" title="Let’s Talk About project.pbxproj"></a>Let’s Talk About project.pbxproj</h3><p><code>project.pbxproj</code> 文件被包含于 Xcode 工程文件 <code>*.xcodeproj</code> 之中，存储着 Xcode 工程的各项配置参数。它本质上是一种旧风格的 Property List 文件，历史可追溯到 NeXT 的 OpenStep。其可读性不如 xml 和 json，苹果却一直沿用至今，作为一家以创新闻名的公司可能这里剩下的就是情怀吧。</p>
<p>本文谈了下 <code>project.pbxproj</code> 的知识，并总结了一些操作工程文件的优秀轮子，并在最后给出了自己的解决方案 <a href="https://github.com/yulingtianxia/pbxprojHelper" target="_blank" rel="external">pbxprojHelper</a>。</p>
<p>阅读请戳：<a href="http://t.cn/Rcg8jUc" target="_blank" rel="external">http://t.cn/Rcg8jUc</a></p>
<h3 id="Swift__u7B97_u6CD5"><a href="#Swift__u7B97_u6CD5" class="headerlink" title="Swift 算法"></a>Swift 算法</h3><p>Ray Wenderlich 上有一个算法系列的专题，叫做《Swift Algorithm Club》，每个月会出一篇文章，介绍如何用 Swift 实现一些基本的算法，最新的一期文章是《Swift Linked List Data Structure》，感兴趣的<a href="http://t.cn/RVzeGCu" target="_blank" rel="external">点这里阅读</a>。</p>
<h2 id="u4F1A_u8BAE"><a href="#u4F1A_u8BAE" class="headerlink" title="会议"></a>会议</h2><h3 id="/dev/world/2016__u5927_u4F1A"><a href="#/dev/world/2016__u5927_u4F1A" class="headerlink" title="/dev/world/2016 大会"></a>/dev/world/2016 大会</h3><p>在澳大利亚举办的 /dev/world/2016 大会结束后，主办方公开的相关的大会演讲视频。视频内容涉及跨平台开发、UI 设计、自动化测试、Swift、函数式编程，欢迎围观：<a href="http://t.cn/RcucyX2" target="_blank" rel="external">http://t.cn/RcucyX2</a>。注意地址在 youtube 上，需要翻墙。</p>
<h2 id="u5F00_u6E90_u9879_u76EE"><a href="#u5F00_u6E90_u9879_u76EE" class="headerlink" title="开源项目"></a>开源项目</h2><p>本周开源项目推荐的是 <a href="https://github.com/castial/HYFileManager/blob/master/Docs/README_cn.md" target="_blank" rel="external">HYFileManager</a>，HYFileManager 一个基于 NSFileManager的文件操作类，它提供一系列的静态方法，只用少量的代码，来处理经常需要处理的文件操作，使得工作更加方便快捷。</p>
<h2 id="u6709_u8DA3"><a href="#u6709_u8DA3" class="headerlink" title="有趣"></a>有趣</h2><p>据说下图表示的是「断点调试」的场景：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/805c3d47jw1f8l8r3389gg20dw0a1b08.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>大家国庆节过得如何？我反正是整个人的作息都变了，估计要调整过来得花不少时间。</p>
<p>国庆节期间开]]>
    </summary>
    
      <category term="iOS weekly" scheme="http://blog.devtang.com/categories/iOS-weekly/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS移动开发周报-第45期]]></title>
    <link href="http://blog.devtang.com/2016/09/26/ios-weekly-45/"/>
    <id>http://blog.devtang.com/2016/09/26/ios-weekly-45/</id>
    <published>2016-09-26T14:15:15.000Z</published>
    <updated>2016-09-26T14:22:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>是的，我又开始写周报了！主要是因为喵神不写周报了，加上我发现大家对写 iOS 技术周报这件事情似乎没什么兴趣。其实我觉得这是一个挺好的学习总结的办法，所以要不就继续我来吧。</p>
<p>我会每周从国外的周报，微博，GitHub，QQ / 微信群里收集各种 iOS 的信息，然后挑选一些有价值的分享给大家。</p>
<h2 id="MDCC"><a href="#MDCC" class="headerlink" title="MDCC"></a>MDCC</h2><p>MDCC 大会刚刚结束，这次大会请来了在日本的喵神王巍，滴滴的孙源，LeanCloud 的陈宜龙等众多 iOS 开发者。会议的所有 iOS 讲稿都会更新到这个地址，感兴趣的同学请一定关注更新：<a href="https://github.com/MDCC2016/iOS-Session-Slides" target="_blank" rel="external">https://github.com/MDCC2016/iOS-Session-Slides</a></p>
<p>王巍提前已经将他的讲稿和 Demo 代码公布在微博上了，地址是：<a href="http://weibo.com/1708947107/E9JHnoNtS" target="_blank" rel="external">http://weibo.com/1708947107/E9JHnoNtS</a></p>
<h2 id="u82F9_u679C_u52A0_u5F3A_u5E94_u7528_u6807_u9898_u5BA1_u6838_u529B_u5EA6"><a href="#u82F9_u679C_u52A0_u5F3A_u5E94_u7528_u6807_u9898_u5BA1_u6838_u529B_u5EA6" class="headerlink" title="苹果加强应用标题审核力度"></a>苹果加强应用标题审核力度</h2><p>你的应用最近因为起名字的原因被拒过吗？在以前，由于标题文字在搜索中的排序权重较高，所以有一些应用会把一些热门关键词写在标题中。苹果对此行为一直管得不严，有些审核员管，有些审核员不管。不过最近似乎每个审核员都更加严格执行这项标准了，那些稍长的名字，都被要求进行进一步的精简。详见：<a href="http://www.gupowang.com/app/5057.html" target="_blank" rel="external">http://www.gupowang.com/app/5057.html</a></p>
<h2 id="u9002_u914D_iOS_10"><a href="#u9002_u914D_iOS_10" class="headerlink" title="适配 iOS 10"></a>适配 iOS 10</h2><p>Xcode 10 发布以后，编译器开始不支持 iOS 7，所以很多应用在适配完 iOS 10 以后，都不再支持 iOS 7 了。我的同事看了一下，包括网易新闻，滴滴出行这些大应用也都选择了不再兼容 iOS 7 的方法。但是也有一些应用选择适配 iOS 10 同时支持 iOS 7，这些应用有 QQ，美团 等。由于 AppStore 支持 iOS 7 的设备下载旧的版本，所以我个人觉得即便不支持 iOS 7，所以不支持 iOS 7 或许是最省事的办法。</p>
<h2 id="Swift_3"><a href="#Swift_3" class="headerlink" title="Swift 3"></a>Swift 3</h2><p>Swift 3 推出之后，Ray 出了一个迁移到 Swift 3 的视频教程，感兴趣的同学可以看看，不过据说，Alarmfire 网络库在适配 Swift 3 后，只支持 iOS 9 以上的版本。这对于国内系统升级缓慢的应用来说，似乎是一个很尴尬的事情。另一个尴尬的事情是迁移 Swift 3 还需要各种第三方库的配合，当前看起来，还需要一些时间。所以，建议大家还是继续使用 Swift 2.3  的版本。<a href="https://videos.raywenderlich.com/screencasts/ios-10-swift-3-in-3-minutes" target="_blank" rel="external">https://videos.raywenderlich.com/screencasts/ios-10-swift-3-in-3-minutes</a></p>
<h2 id="Push_Notifications"><a href="#Push_Notifications" class="headerlink" title="Push Notifications"></a>Push Notifications</h2><p>苹果最近改进了它的 Push Notifications 使用方式，除了可以使用以前的证书验证方式外，增加了一种名为 Token Authentication 的方式。苹果原话说： A token is easy to generate, doesn’t expire, and can be used to send notifications to all of your apps. 感兴趣的读者可以试试，相关链接：<a href="https://developer.apple.com/news/?id=09222016a" target="_blank" rel="external">https://developer.apple.com/news/?id=09222016a</a></p>
<h2 id="Vapor"><a href="#Vapor" class="headerlink" title="Vapor"></a>Vapor</h2><p>Vapor 1.0 正式发布了，这是一个基于 Swift 的服务器端框架，感兴趣的朋友可以玩玩。<a href="http://vapor.codes/" target="_blank" rel="external">http://vapor.codes/</a></p>
<h2 id="u6709_u8DA3"><a href="#u6709_u8DA3" class="headerlink" title="有趣"></a>有趣</h2><p>最近 AppStore 的热门搜索出现了奇怪的词条，详见下面第三条，看不懂的别问我，我也不懂！请向老司机请教！</p>
<p><img src="http://ww2.sinaimg.cn/mw690/65dc76a3jw1f7zsq678yij20qo1bf410.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>是的，我又开始写周报了！主要是因为喵神不写周报了，加上我发现大家对写 iOS 技术周报这件事情似乎没什么]]>
    </summary>
    
      <category term="iOS weekly" scheme="http://blog.devtang.com/categories/iOS-weekly/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是爱 - 读《少有人走的路》]]></title>
    <link href="http://blog.devtang.com/2016/09/16/what-is-love/"/>
    <id>http://blog.devtang.com/2016/09/16/what-is-love/</id>
    <published>2016-09-16T15:04:36.000Z</published>
    <updated>2016-09-16T15:04:36.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/the-road-less-traveled-book.jpg">
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>爱是什么？这或许是一个永恒的话题。我很少从学校的传统教育以及家庭教育中获得这方面的知识。</p>
<p>我小的时候对于爱的解释，印象中的故事竟然都是来自是电影：一部是 <a href="http://baike.baidu.com/item/%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7/6162581" target="_blank" rel="external">《泰坦尼克号》</a>，另一部是 <a href="http://baike.baidu.com/item/%E7%9C%9F%E7%88%B1%E8%87%B3%E4%B8%8A/1671898" target="_blank" rel="external">《真爱至上》</a>。《泰坦尼克号》的男主 Jack 为了心爱的人，放弃自己生存的机会，让我以为爱是一种牺牲。而在大学时看的《真爱至上》，电影中的 10 个故事，讲了各种各样爱的故事，有小朋友之间的爱，有情侣之间的爱，更有同性之间的爱。电影最后的一句台词给爱下了一个更广泛的定义：「Love actually is everthing.」，</p>
<p>我现在 30 多岁了，结婚了，也有了小孩，有些时候我觉得爱就一种亲情，但是又说不清楚。因为家庭生活中其实会有各种琐事，各种争吵，有些时候也会困惑，不知该如何处理。</p>
<p>还是要感谢李笑来老师，他推荐的这本 <a href="http://item.jd.com/11323419.html" target="_blank" rel="external">《少有人走的路》</a>，用更详尽的篇章，从一个学术的角度讨论了什么是爱。这本书的作者斯科特·派克是一个心理医生，在书中的第二部分，作者详尽分析了各种关于爱的行为，告诉我们什么样的行为是爱，什么样的行为不是爱。</p>
<h2 id="u7231_u7684_u5B9A_u4E49"><a href="#u7231_u7684_u5B9A_u4E49" class="headerlink" title="爱的定义"></a>爱的定义</h2><p>作者从他的角度，给爱下了如下的定义：</p>
<blockquote>
<p>爱，是为了促进自我和他人心智成熟，而具有的一种自我完善的意愿。</p>
</blockquote>
<p>这个定义非常有意思，完全不同于我们以前了解到的爱的描述，我们从中可以看到两个特征：</p>
<ol>
<li>爱可以使双方都获得心智成熟。这就像是杨过和小龙女的「双修」一样，是一种共同进步的互利行为。</li>
<li>爱是一种自我完善的意愿。我们都希望通过它获得心智的成熟，人格的独立。</li>
</ol>
<h2 id="u7231_u7684_u8BEF_u89E3"><a href="#u7231_u7684_u8BEF_u89E3" class="headerlink" title="爱的误解"></a>爱的误解</h2><p>弄清楚什么是爱是很难的，但是反过来，弄清楚什么不是爱相对来说容易一些，所以本书中分析了四种常见的错误的「爱」，分别是：坠入情网、依赖性、自我牺牲、（仅有）感觉。</p>
<h3 id="u5760_u5165_u60C5_u7F51"><a href="#u5760_u5165_u60C5_u7F51" class="headerlink" title="坠入情网"></a>坠入情网</h3><p>坠入情网不是爱。这可能是最常见的误区吧。年轻时的我们，由于荷尔蒙的分泌，对异性产生好感，进一步渴望和异性交往，然后坠入情网，最终啪啪啪以及结婚生子。作者认为坠入情网不是爱的核心理由是：坠入情网的 “爱” 不会持续太久，不管爱的对象是谁，早晚我们都会从情网的羁绊中 “爬出”。有一个词叫「七年之痒」，其实也是说这个道理。坠入情网这种爱更像是一种冲动和激情，随着时间会慢慢消退。</p>
<p>刚刚说到爱需要使双方心智变得成熟。但是坠入情网，惟一的好处就是消除寂寞。即便经由婚姻，使这一功用得以延长，也无助于心智的成熟。</p>
<p>悲观一点说，坠入情网其实是一种受人类本能控制的，来自我们 DNA 中繁衍需求的刺激。它的意义在于增加人类生殖机会，促进物种繁衍和生存。但是坠入情网其实是产生真正的爱的一个很好的媒介，后面我们再详细讨论。</p>
<h3 id="u4F9D_u8D56_u6027"><a href="#u4F9D_u8D56_u6027" class="headerlink" title="依赖性"></a>依赖性</h3><p>依赖性不是爱。我们会见到各种依赖性的行为，比如小孩对父母的依赖，妻子对丈夫的依赖，甚至父母对小孩也有依赖。一些小孩长大之后离开家门，父母会特别难受，但都会调整接受。如果一个父母因为对小孩有依赖，阻止孩子去外地上学或者工作，那么这种依赖性就不是爱了，因为它其实对孩子的发展并不有利。</p>
<p>反过来，父母的这种行为对于自己也是不利的，因为这也体现出他们的人格并不独立。总有一天，孩子还是会追求自由与不受控制，到时候父母也容易产生心理问题。</p>
<p>所以，过度的依赖行为其实使孩子和父母都丧失了人格的独立性，是不利于心智发展的，所以不是爱。</p>
<h3 id="u81EA_u6211_u727A_u7272"><a href="#u81EA_u6211_u727A_u7272" class="headerlink" title="自我牺牲"></a>自我牺牲</h3><p>自我牺牲不是爱。我们常常见到这样的行为：爷爷奶奶给孙子孙女买特别多的玩具，什么事情都惯着孩子，为了满足孩子的各种需求，甚至会牺牲一些自己的东西，例如金钱，健康，时间。这些牺牲如果是利于孩子身心发展的，那就是爱；如果最终使得孩子产生很坏的生活习惯和沟通方式，那么不但不是爱，还是一种伤害。</p>
<p>所以，自我牺牲的付出不一定是爱，还得看付出之后的效果是怎样的。</p>
<h3 id="u611F_u89C9"><a href="#u611F_u89C9" class="headerlink" title="感觉"></a>感觉</h3><p>爱，不是感觉。爱是一种行为，而不是一种感觉。如果你整天只是把爱挂在嘴上，但是并没有任何行为付出，那么其实这就不是爱。作者在书中指出，一些家庭的父母并不关心孩子的身心，只知道通过简单粗暴的方式来教育孩子，嘴上说是爱孩子，其实根本就没有付出真正上的行为。</p>
<p>作为父母，把孩子喂饱，提供教育相关的资金支持，仅仅是尽到了最基本的义务。而和孩子一起玩耍，交流，解决孩子的困难，纠正孩子的错误，关注和帮助孩子成长，才是更重要的行为。</p>
<h2 id="u5982_u4F55_u7231"><a href="#u5982_u4F55_u7231" class="headerlink" title="如何爱"></a>如何爱</h2><p>那么，我们应该如何去爱呢？作者介绍了一些原则：</p>
<ol>
<li>首先，爱与不爱最显著的区别之一，在于当事人的意识思维和潜意识思维的目标是否一致。</li>
<li>第二，爱是长期的和渐进的过程。爱是自我完善，意味着心智不断成熟。爱，能够帮助他人进步，也会使自我更加成熟。</li>
<li>第三，真正意义上的爱，既是爱自己，也是爱他人。爱，可以使自我和他人感觉到进步。不爱自己的人，绝不可能去爱他人。</li>
<li>第四，爱是自我完善，也是帮助他人完善。它意味着持续努力，超越自我界限。</li>
</ol>
<p>在以上原则下，作者提供了一些实践的办法：</p>
<ol>
<li>关注：爱最重要的体现形式，就是关注。体现关注，一种最常见、最重要的方式，就是 “倾听”。</li>
<li>自律：自律，是将爱转化为实际行动的过程。这里面涉及情绪的控制，我们既不能过于放纵情绪，也不能过于压抑情绪。</li>
<li>独立：爱的重要特征之一，在于爱者与被爱者都不是对方的附属品。付出真爱的人，应该永远把爱的对象视为独立的个体，永远尊重对方的独立和成长。</li>
</ol>
<p>最终，如果我们这么做，就会产生精神贯注的现象：</p>
<blockquote>
<p>真正的爱，是自我完善的特殊体验，跟自我界限有着密切关联。陶醉在爱的情感里，我们感觉灵魂无限延伸，奔向心爱的对象。我们渴望给对方滋养，我们希望对方成长。被自我界限之外的对象吸引，迫使我们产生冲动，想把激情乃至生命献给对方，心理学家把这样的激情状态，称为 “精神贯注”。我们贯注的对象，正是所爱的人或所爱的事物。</p>
</blockquote>
<h2 id="u7231_u7684_u98CE_u9669"><a href="#u7231_u7684_u98CE_u9669" class="headerlink" title="爱的风险"></a>爱的风险</h2><p>即便我们做到了真正的爱，但是也会面临一些风险：</p>
<ol>
<li>死亡的风险：精神贯注的代价之一，似乎是或早或晚你都要因为贯注对象的死亡或离去，让自己饱受痛苦的折磨。如果不想经受个中痛苦，就必须放弃生活中许多事物，包括子女、婚姻、性爱、晋升、友谊，但惟有这些事物，才能够使人生丰富多彩。</li>
<li>独立的风险：我们必须不再完全依赖任何人，成为一个人格独立的个体。</li>
<li>承诺的风险：我们需要具有责任感，承诺与爱相关的义务。</li>
<li>冲突的风险：我们需要面临与所爱的人的冲突，并且在冲突发生时，以帮助对方心智成熟作为出发点，来解决冲突。只有以爱为出发点，投入全部的情感，做出真挚的承诺，才能更好地滋养对方的心灵。例如，父母和孩子发生冲突时，首先应该自我检讨，认清自己的价值观，才能采取正确的方式，才能恰当地教育孩子。</li>
</ol>
<p>关于死亡的风险我深有感触。我现在 30 岁了，整个身体都不像 20 多岁那样有活力了，加班太晚会感觉特别累。我相信有一天，我会发现自己真的老了，不光精力大不如从前，可能视力，听力都退化了，那个时候我需要放弃很多年轻时获得的成就，但是这就是人生，所有人都逃避不了死亡。</p>
<p>关于冲突，我也有一些体会。我有时候在家里会抱怨一些事情，后来我发现，这除了让我和家人产生矛盾以外，完全无助于解决任何问题。所以我开始反思我是否应该用更加有效的方式来和家人沟通，试过几次之后，我发现家人也这些事情也有自己的看法。在冲突发生时，用诚实和谦逊的态度先自我反省，再进一步沟通，最终大家会学会到更好的相处方式。这确实也让我的心智更加成熟了，对情绪的控制（自律能力）更强了。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><a href="http://item.jd.com/11323419.html" target="_blank" rel="external">《少有人走的路》</a> 让我对爱有了更客观的认识，一句话总结：爱就是一种精神贯注的行为，它可以使自己和对方的心智都成长起来，从而获得健全的人格。</p>
<p>但是作者也坦诚地说，这样的定义还是无法解释很多爱的行为，不过对于我来说，已经学到很多了，推荐给大家。以下是本书第二部分的思维导图总结：</p>
<img src="/images/the-road-less-traveled-mindnode.jpg">
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/the-road-less-traveled-book.jpg">
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打开你的脑洞]]></title>
    <link href="http://blog.devtang.com/2016/09/04/open-your-brain/"/>
    <id>http://blog.devtang.com/2016/09/04/open-your-brain/</id>
    <published>2016-09-04T14:20:11.000Z</published>
    <updated>2016-09-04T14:28:04.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/open-brain.jpg">
<h2 id="u804C_u4E1A_u75C5"><a href="#u804C_u4E1A_u75C5" class="headerlink" title="职业病"></a>职业病</h2><p>我的大学是在北京师范大学读的，当时读的一个叫做「励耘实验班」的专业（现在已经取消了），美其名曰第一年进行通识教育，第二年选专业。我最终选择了计算机专业，并且有幸和一群不同专业的室友一起生活了四年。</p>
<p>其中一个室友选了「数字媒体」专业，他在专业学习过程中，需要每天看各种电影，分析各种电影片段的拍摄手法。那个时候（03 年）网络还不发达，他有一个大书架，上面全是他买的各种电影光盘。有一次和他聊天，他说道：「我现在看电影已经无法融入剧情中了，因为我一看见电影，脑海里面想的就是当前的摄像机机位在哪里，用了什么拍摄手法，为什么导演要用这样的手法」。</p>
<p>有人把这种现场取一个名词，叫「职业病」，就像警察一样，不管有没有上班，都会下意识地观察有没有行为异常的路人。而我做为一个 iOS 开发者，每每试用一款新的 App，看到一些交互效果，第一想到的不是这个效果多酷，而是想这个效果是用什么技术方案做到的。</p>
<p>我以前觉得这就是「职业病」，但是突然有一天，我发现这还不是「职业病」这么简单的事情。</p>
<h2 id="u8111_u6D1E"><a href="#u8111_u6D1E" class="headerlink" title="脑洞"></a>脑洞</h2><p>事情的转折发生在我开始转型，从一个 iOS 开发，转变为一个团队管理者。我开始参与产品和 UI 的讨论。这个时候，我发现我开始关注技术实现之外的东西，拿到一款 App，我不但会考虑它的技术实现，也会考虑产品经理这么设计的意图，也会考虑用户使用这个功能的场景，还会考虑视觉设计的特点。</p>
<p>于是，我觉得这不是职业病，而是打开了另一个思考问题角度的脑洞。</p>
<p>就像我的室友打开了「艺术创业」的脑洞一样，他可以从各种电影中吸取到电影拍摄的专业知识，而我却对此完全不会有感受。同样，我使用一个 App 可以带来技术实现上的思考和提升，而我的室友却完全不可能有这方面的感受。</p>
<p>每一个脑洞的打开，都代表着一种新的观察世界的视角，以及这个视角下的思考、学习和积累。iOS 开发者由于需要大量地接触到终端用户，产品原型以及 UI 设计，本来可以学习和积累出大量的产品设计、交互设计 和 UI 设计的知识，但大部分 iOS 开发者在面对产品稿的时候，却只知道思考这个功能应该如何实现。这些 iOS 开发者只打开了技术实现的脑洞，无论他们做多少个 App，他们也无法得到产品设计上的提升。</p>
<p>另外有一些 iOS 开发者，他们喜欢和产品经理聊天，了解产品稿背后的设计意图，他们还会反馈给 UI 设计师一些 iOS 下的视觉规范。在一些产品设计非常难以实现的时候，他们会站在产品经理的立场上，提出不损害产品意图，又有更容易实现的技术折中方案。这些 iOS 开发者，不但打开了技术实现的脑洞，也打开了产品设计，视觉设计的脑洞。每一次 App 的开发过程，他们除了能够提升开发能力，还能提升产品设计和视觉设计能力。</p>
<p>服务器端的同学在这一点上，会吃亏很多，因为服务器端的同学大多数不需要接触 UI 稿，产品稿方面，他们的工作因为不涉及交互细节，所以也很容易忽视产品实现的细节。相对来说，他们更难以打开产品设计，视觉设计的脑洞。</p>
<h2 id="u611F_u53D7"><a href="#u611F_u53D7" class="headerlink" title="感受"></a>感受</h2><p>每一个脑洞都代表着一种新的思考问题的角度。我现在管理小猿搜题产品技术团队，我开始越来越关注大家的工作流程，沟通方式是否顺畅，希望让每一个人都能舒服地工作，高效地产出。这个时候，我打开了管理的脑洞，我开始注意到大家的协作方式，注意到非正式领导的组织过程，注意到跨组协作的效率问题，注意到细节问题的处理过程。我会观察和思考这些事情，甚至会尝试给组织加入一些规则或增加一些沟通来改善一些问题，这想在这个团队中，很少有人会像我一样关注这些问题，所以他们也很难像我一样积累出团队管理经验。</p>
<p>当你理解了这件事情之后，你就可以打开更多的脑洞了，因为很多经验的积累，并不真正需要你全职去做，而只要你仔细观察就可以了。比如你可以打开 CTO 的脑洞，看看公司的 CTO 是如何管理整个技术团队的，你还可以打开 CEO 的脑洞，看看 CEO 在哪些问题上会向员工沟通，前几天，<a href="http://www.yunweipai.com/archives/9363.html" target="_blank" rel="external">《李大学：CTO，应该像 CEO 一样思考》</a> 其实讲的也是这个道理。你甚至可以打开餐馆老板的脑洞，观察公司楼下的各种餐馆的经营模式，哪些最后死掉了，哪些最后成功了。</p>
<p>作为一个普通 iOS 开发者，我们更应该打开的是自己上司的脑洞，看看你的老大（他或许是一个 iOS 团队负责人）是如何负责一个团队的。这样，你也可以学习到他需要哪些信息，他会怎么决策，从而有效地和他进行沟通，让他对你的工作满意。</p>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>打开脑洞这个叫法是我自己发明出来的，你喜欢这个思考方式吗？</p>
<p>一旦你被我打开了「打开脑洞」的脑洞，你就停不下来了，好好享受从新视角观察世界的乐趣吧！</p>
<p>祝大家玩得开心！</p>
<p>如果你感兴趣，这儿还有我的另一个脑洞：<a href="/2016/07/20/programming-worlds-farmer-and-god/">《软件开发中的上帝模式与农民模式》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/open-brain.jpg">
<h2 id="u804C_u4E1A_u75C5"><a href="#u804C_u4E1A_u75C5" class="headerlink" title="职业病"></a>职业病</h2><p>我的大]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人格化的公司]]></title>
    <link href="http://blog.devtang.com/2016/09/04/company-with-personality/"/>
    <id>http://blog.devtang.com/2016/09/04/company-with-personality/</id>
    <published>2016-09-04T13:19:39.000Z</published>
    <updated>2016-09-04T13:19:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4F01_u4E1A_u7684_u54C1_u724C_u5F62_u8C61_u4E0E_u7BA1_u7406_u8005_u7684_u54C1_u724C_u5F62_u8C61"><a href="#u4F01_u4E1A_u7684_u54C1_u724C_u5F62_u8C61_u4E0E_u7BA1_u7406_u8005_u7684_u54C1_u724C_u5F62_u8C61" class="headerlink" title="企业的品牌形象与管理者的品牌形象"></a>企业的品牌形象与管理者的品牌形象</h2><p>在过去，企业总是希望将企业品牌形象与企业的管理者的品牌形象区分开，因为一个长久的百年老店可能经历多次管理者的变更。IBM 就是一个例子，我们不记得 IBM 的 CEO，但是 IBM 在企业服务方面高质量的品牌形象还是深入人心的。</p>
<p>传统的企业这么做无可厚非，因为他们不希望企业的管理者由于健康或别的原因，给企业带来负面影响。在传统企业盈利模式和管理方式稳定的时期，聘用一个 “职业经理人” 一样的 CEO，对于企业来说风险也不大。</p>
<p>但是，现在的企业发展速度已经远远超过了过去。</p>
<h2 id="u5E74_u8F7B_u516C_u53F8_u7684_u5FEB_u901F_u5D1B_u8D77"><a href="#u5E74_u8F7B_u516C_u53F8_u7684_u5FEB_u901F_u5D1B_u8D77" class="headerlink" title="年轻公司的快速崛起"></a>年轻公司的快速崛起</h2><p>2005 年：全球市值最大的公司分别是通用电气，美孚石油，微软，花旗，沃尔玛，BP 能源，辉瑞，美洲银行，强生，汇丰银行。</p>
<p>到了 2015 年，全球市值前十公司：苹果，谷歌，微软，伯克希尔，美孚石油，亚马逊，Facebook，通用电气，强生，富国银行。从中我们可以看到像 Facebook 这类公司的快速崛起。</p>
<p>Facebook 2004 年成立，淘宝 2003 年成立，这些公司都花了不到 10 年的时间，就成为了估值上千亿美金的公司。飞速的发展速度，使得大家不再担心企业创始人的个人魅力与企业的品牌形象融合在一起。</p>
<p>而且，企业管理者的个人魅力和企业本身的品牌形象其实是有相互影响的叠加作用，当企业管理者在公众中具有光环效应时，对企业品牌本身也是一种无形的帮助。在现在的中国公司中，各种企业的创始人都会注意使用个人的魅力或人格，来给自己的公司产品宣传背书。</p>
<p>比如锤子手机的罗永浩，360 的周鸿祎，小米的雷军，乐视的贾跃亭。对于他们来说，企业的成功至关重要，能够有一个核心的 “代言人”，是更加利于产品宣传的。这个趋势也就是近年来才开始盛行，反观老牌的中国公司 BAT 以及门户网站网易搜狐新浪，他们的创始人都要低调得多。也就是说，创新型企业的快速发展，使得越来越多创业公司采用这样的策略。</p>
<h2 id="u60C5_u611F_u5316_u8BA4_u77E5"><a href="#u60C5_u611F_u5316_u8BA4_u77E5" class="headerlink" title="情感化认知"></a>情感化认知</h2><p>从用户认知方面，一个具象化的人格形象，是更加有利于消费者对于企业产生认知，并且生成情感联系的。大家对于罗永浩的认知是一个理想主义者，那么就可能会为 “情怀” 买单。很多消费者的消费都是 “非理性” 的，一款产品所传达出来的任何情感（例如环保，坚持不懈，创新精神，极客精神）都会吸引到消费者，让他们购买产品而表达和宣泄自己的情感。</p>
<p>人格化的企业形象，会更加利于情感联系的建立。传统企业会选择明星代言的方式来做这方面的事情，但是明星可能会过气或者有负面新闻，都会对企业带来影响。一家新成立的创业公司请明星代言需要付出巨大成本，从性价比来说，让公司创始人给公司 “代言” 会更加经济和有效。所以我们甚至看到了聚美优品的陈欧为自己产品 “代言” 的营销方案。</p>
<h2 id="u4EBA_u683C_u5316_u7684_u65B0_u516C_u53F8"><a href="#u4EBA_u683C_u5316_u7684_u65B0_u516C_u53F8" class="headerlink" title="人格化的新公司"></a>人格化的新公司</h2><p>在可以预见的未来，创业公司的创始人会更加注意使用社交媒体来树立个人品牌，然后利用个人品牌为自己的产品带来竞争力。今年正好是自媒体爆发的元年，我们看到了更多个人在垂直领域创业的故事，<a href="http://weibo.com/u/149691505" target="_blank" rel="external">罗振宇</a>，<a href="http://weibo.com/wenyi" target="_blank" rel="external">文怡</a>，<a href="http://weibo.com/u/3688920760" target="_blank" rel="external">凯叔</a>，<a href="http://weibo.com/cuiyutao" target="_blank" rel="external">崔玉涛</a>，他们的公司都发展得很快。</p>
<p>所以我相信，在未来的企业中，创始人的个人品牌会被进一步强化，而那些拥有个人品牌的创业者，除了在竞争中占据巨大的品牌宣传优势外，也能在消费者的心智中建立起一个「人格化」的公司形象。</p>
<p>让我们拭目以待。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4F01_u4E1A_u7684_u54C1_u724C_u5F62_u8C61_u4E0E_u7BA1_u7406_u8005_u7684_u54C1_u724C_u5F62_u8C61"><a href="#u4F01_u4E1A_u7684_u54C1_u]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我们身边的技术人生 -《技术人创业攻略》]]></title>
    <link href="http://blog.devtang.com/2016/09/01/dev-level-up-stories/"/>
    <id>http://blog.devtang.com/2016/09/01/dev-level-up-stories/</id>
    <published>2016-09-01T14:02:34.000Z</published>
    <updated>2016-09-01T14:02:34.000Z</updated>
    <content type="html"><![CDATA[<p>在这个信息爆炸的移动互联网时代，我们身边总会有一些技术圈的大牛出现，介绍他们的文章大多是以技术角度，描述他们的作品多么牛逼，而我们往往除了膜拜也无从知晓这些技术人的成长经历。</p>
<p>带着写一些「有趣」的技术人故事的初心，《技术人创业攻略》的作者张兰开始了她的乌托邦式的旅程。她从 2013 年开始，从 SegmentFault 的创始人高阳，开始了她的访谈之旅。当时张兰并没有工作，每篇访谈耗费她大量精力，最后都免费放到网上供大家阅读。</p>
<p>带着这样的初心，她一直坚持完成了 37 位不同年龄，不同技术领域，不同背景的技术人。在她的采访稿中，她以技术人的真实背景出发，试图揭示出这些人成功的原因。</p>
<p>这些被他采访的技术人里面，包括 SegmentFault 的创始人高阳，七牛云存储的创始人许式伟这些创业公司的 CEO，也包括擅长运营的前端领域的一姐田爱娜，也有深入开源社区，成为 Linux 内核核心贡献者的吴峰光，还有资本领域的天使投资人杨轩。我也有幸在一次阿里举办的技术沙龙上认识了她，继而成为了她笔下的一个技术成长故事。</p>
<p>因为张兰写的这些故事都很有趣，于是有出版社愿意将它出版成书，这就是《技术人创业攻略》。但是张兰的性格里面有着极强的「处女座」式的追求完美的情结。所以这本书整整花费了她将近一年的时间进行重新的内容梳理和再采访。</p>
<p>仅仅为了封面的设计，张兰就多次因为不满意而调整，最后还是找到了西乔设计封面（下图）才满意。此时西乔的公众号已经成为几十万粉丝的大号了，如果你还没有看过程序员的漫画，一定得关注一下：「神秘的程序员们」（coderstory）。</p>
<img src="/images/dev-level-up.jpg">
<p>最终在上个月，《技术人创业攻略》终于出版了。不过在本书出版的时候，张兰已经和她老公旅居到了加拿大，开始了一段新的生活。而张兰此时开始学习上了 JavaScript，打算成为了一个前端工程师。她的第一个小作品，是用 DFS 生成的一个迷宫，我专门看了看她的代码：<a href="https://github.com/Graciazl/RandomMazeGame/blob/master/script.js" target="_blank" rel="external">https://github.com/Graciazl/RandomMazeGame/blob/master/script.js</a>，整体的代码风格和结构完全不像是一个初学者。我想这就是我认识的张兰最好的描述：做什么事情都那么认真。</p>
<img src="/images/zhanglan-maze.jpg">
<p>最后我得到了张兰的授权，为大家附上《技术人创业攻略》书中节选的一篇内容。这是书中唯一一位受访的外国人：Dave Thomas，《程序员修炼之道》的作者，让我们看看在张兰笔下的大神是如何成长的。</p>
<hr>

<h2 id="Dave_Thomas_uFF1A_u751F_u547D_u4E0D_u606F_uFF0C_u7F16_u7A0B_u4E0D_u6B62"><a href="#Dave_Thomas_uFF1A_u751F_u547D_u4E0D_u606F_uFF0C_u7F16_u7A0B_u4E0D_u6B62" class="headerlink" title="Dave Thomas：生命不息，编程不止"></a>Dave Thomas：生命不息，编程不止</h2><p>Dave Thomas，是一位从业近 40 年的大神级人物，他和 Andy Hunt 于 1999 年合著的《The Pragmatic Programmer》（中文译名《程序员修炼之道》），是历史上最畅销的开发指南书籍，曾获得 Jolt 大奖，影响深远。Dave 是敏捷宣言的 17 位发起人之一，Ruby 语言的支持者和传播者，正是他对 Ruby 语言的传播，使 Ruby 逐渐成为与 Perl，Python 齐名的语言。2003 年，他和 Andy Hunt 成立了 The Pragmatic Bookshelf 出版公司，致力于出版软件开发相关书籍，并用开发软件的方式实现了图书出版业的重大突破。</p>
<p>Dave Thoma 是一位令人尊敬的大师，更是一位伟大的程序员。在近 40 年的从业生涯中，他从未间断过编程，并时刻保持旺盛的好奇心和探索新技术的热情。在 Ruby Conf China 2013 大会上，Dave 接受了技术人攻略的访谈邀请，并在回信中 100% 地肯定了技术人攻略 “传递技术热情” 的理念：</p>
<p>“I think your ideas about spreading passion are 100% correct. I would love to help spread this message.”</p>
<p>希望大师的访谈可以鼓励更多还在奋斗的程序员，技术人攻略也会继续把这种对技术的热爱传递给更多的人。</p>
<blockquote>
<p>技术人攻略：您从什么时候开始接触编程？编程带给了您什么样的乐趣？在不断超越自我的过程中，是否遇到过什么困难，是否曾有过想放弃的时刻呢？</p>
</blockquote>
<p>我初次接触编程是在 1972 年，那时我还在英国上高中。有一部分人提前完成了考试，在学校没有别的事情可做。正巧校园对面的科技学院开设了编程课，于是我们申请了参加这个一周两次的课程。</p>
<p>我最初打算学数学专业，但当我开始编程，我慢慢爱上了它。</p>
<p>那时候我用 Basic 语言，将代码敲到纸带上，通过一台 110 波特的调解器将数据传到大型机上运行。虽然如此麻烦，但我发现编程十分符合我的大脑的运作方式——我喜欢这种创造性和精确性兼备的体验。</p>
<p>从那时开始，我从未间断过编程。我十分确定——除非是在度假的时候，我生命中的每一天都离不开写代码。</p>
<p>我也常常会有感到艰难的时候，但每次考验过去之后，你的技艺都将更上一层楼。所有值得做的事情都是困难的，但克服这些挑战不仅会让你更强大，还会让你变得更加投入。</p>
<blockquote>
<p>技术人攻略：我们处在一个快速变化的时代，新的技术层出不穷，程序员应该如何保持和这个世界同步，持续提升自己的竞争力？</p>
</blockquote>
<p>想要跟上技术更新的速度越来越难。当我开始编程的时候，主要通过阅读书籍和杂志了解进展，但现在几乎每天都有新概念出现。</p>
<p>但事实上很多的新事物只是人们对旧东西的再发明。我们行业里的许多人，眼光只看向将来，对计算机的历史却知之甚少。这些人想要创造东西（当然是好的），但他们并不知道自己想做的东西在 20 或 30 年前已经实现了。</p>
<p>正因为如此，许多新生成的事物其实并没有那么新。对我来说，要跟上潮流就变得简单了，因为看到它们就会让我想起 “啊，这和 X 很像呢”。</p>
<p>但同时，也确实有一些不错的创新。我每个月总有那么一到两次，会遇到很有意思的东西，让我有兴趣去尝试一下。阅读技术内容是有趣的，但只有通过尝试才能认识得更加深入。</p>
<p>这很花时间，但对于程序员来说这种投入非常重要。如果不这么做，很快我们就会被淘汰。</p>
<blockquote>
<p>技术人攻略：在大公司里，职位被划分得很细，例如前端、后端、运维、数据库等，程序员被固定在了公司设定的职位上，您认为程序员应如何提升技术的广度和深度？</p>
</blockquote>
<p>专业化分工属于昆虫世界。真正能够改变世界的人：他们具备更加广泛的能力，并能将不同的技术结合起来创造价值。</p>
<p>我认为很多公司并没有意识到这点，他们更乐于创造层级制度和把员工限制在某个职位上。</p>
<p>但是也有些不一样的公司，懂得通过制定目标和提供指导让程序员有最好的产出，而不是监督所有的细节。这些公司理解一个优秀的程序员可以同时胜任数据库设计、规划应用部署，也许还喜欢解决技术支持方面的问题。</p>
<p>我鼓励年轻程序员获取一些在不同的公司工作的经验，以寻找适合自己的工作方式。例如试试在大公司和在创业团队工作有什么不同，甚至尝试下独自工作。一旦你了解了自己适合的方式，就可以找到或者创造出合适的职位，让自己做得更好。</p>
<p>作为一名员工，很容易抱怨自己的公司，或者怀有这样的想法 “我就是一个普通人，没有能力改变什么”。但事实上，你有责任作出改变——让事情变得更好。这种责任不仅是对公司的，而且也是对自己的。看看你是否能让公司有所改变，如果无法改变现状，那么你应该换一个更适合自己的环境。</p>
<blockquote>
<p>技术人攻略：《The Pragmatic Programmer》影响了非常多的人，如果这本书出修订版，您打算做哪些改变？今天，一个讲求实效的程序员正在做些什么？</p>
</blockquote>
<p>我和 Andy Hunt 常常会讨论这件事。实际情况是，虽然书上的案例看上去古老了一点，但背后的概念仍然很适用。无论你是做 C++ 还是 Javascript 编程，DRY（注：DRY 即 Don’t Repeat Yourself，不要重复自己）原则仍然适用:)</p>
<p>我个人认为可以修改或者去掉一些小的 tips，但没什么大问题。</p>
<p>如何做一个高效的程序员：do what works, and work at what to do。“do what works” 意味着你应该不断问自己 “我正在做的事情有什么样的价值？”，每天都尝试寻找提升所做事情价值的方法。“work at what to do” 意味着要时常回顾，从全局角度看问题，并且寻找改进工作的新方法。</p>
<blockquote>
<p>技术人攻略：您是一名技术高手，又拥有自己的软件公司，您觉得程序员应该创业吗？程序员创业有哪些优势和劣势？</p>
</blockquote>
<p>这是一个很棒的问题，但我也还不知道答案。</p>
<p>我的一个弱点在于我喜欢让事情保持简单——我认为大多数程序员都喜欢这点。但现实世界——公司运作的世界，并不简单。我不得不克服把事情过度简单化的诱惑，因为我知道这样会让自己错失机会。</p>
<p>我认为程序员从事商业，最重要的强项在于我们懂得事物的关系如何。管理代码的原则，同样可以用在管理公司上，这也是 The Pragmatic Bookshelf 这家出版公司成功经营的原因之一。我们在一开始的时候，并不知道图书出版公司该如何运行，所以我们采用了管理软件公司的方式去产出图书，而不是产出代码。结果，我们将版本控制、持续系统构建，以及全自动化等方式运用在了商业运营的方方面面。其它出版商无法做到这些，我们对于出版行业的无知成为了最大的优势。</p>
<blockquote>
<p>技术人攻略：在 Ruby 大会上听说您最近在关注一门新语言 Elixir，它为什么吸引您？您会像推广 Ruby 一样去推广这门语言吗？它是否代表了接下来的技术流行趋势？</p>
</blockquote>
<p>我非常确信未来的世界属于并行和分布式，五年之内，还要编写一个从头到尾顺序化执行的程序，这将是一个笑话。</p>
<p>但同时我们并没有拥有真正可以让我们创建分布式和并行系统的工具，用 Ruby 或 Java 写并行代码很容易出错，用 Javascript 也同样痛苦。</p>
<p>Erlang 诞生差不多 25 年了，这种语言的目的就是要进行分布式和并行编程，就是解决大规模和可靠性问题——在后者的环境中，要保持代码一直处于运行状态，即使代码在升级时也是如此。</p>
<p>Elixir 则没有这个问题，这种语言看上去跟 Ruby 很像，非常易于理解和编写。但是它运行在 Erlang 虚拟机上，这意味着它可以获得 Erlang 的一切好处。同时又可以胜任 Erlang 完成不了的任务，它有很强的元编程能力、宏和协议等方面也不错。</p>
<p>Elixir 会统治世界吗？可能不会。但我认为它代表了未来的方向。学习 Elixir 的过程可以让我理解未来的编码方式。五年后我可能不会用 Elixir，但我十分确信我会用一些类似的语言，我通过 Elixir 学到的东西仍然可以帮助我。</p>
<p>这听上去好像是我认为 Elixir 不会流行，但其实我不这么想。到目前为止，Elixir 是我们所拥有的最好的语言和运行时之一。当我没有为（由 Ruby 编写的）已有系统写代码的时候，我会用 Elixir 开发，我十分喜欢它。</p>
<p>我鼓励其他程序员试试 Elixir(或者其它类似的语言)，我总是鼓励程序员去学习更多的东西。</p>
<blockquote>
<p>技术人攻略：在移动互联网时代，产品的开发模式和以前互联网时代相比，有哪些新特点？</p>
</blockquote>
<p>我认为程序员面对的世界和五年前相比有了显著的变化。浏览器基本上还和 IBM 将老式 3270 终端连到主机上的应用一样——你向它发送数据，用户输入一些东西，然后浏览器给出回应。还是以服务器为主。我知道：客户端在不断加入很多令人头痛的东西，比如 JavaScript 应用什么的，但是整体架构仍然一样。我认为浏览器技术基本上已经进入死胡同。我观察身边的人——他们在手机和平板上使用 App，只有在必须用到浏览器的时候才会用一下，移动世界是以用户为核心，而非以服务器为核心的。</p>
<p>在移动 App 上，客户端掌管一切，服务器仅仅作为资源提供方。这要求程序员掌握一些新的技能和技术支持这种结构。在客户端，我们需要通过编写复杂的，异步的应用，并且将这些应用运行在一系列不同的设备上（不仅是手机和平板）。在服务器端，我们需要从 Rail 风格的应用转向更灵活、更多以联合方式运行的架构。（这正是 Elixir 令人兴奋的原因之一。）</p>
<blockquote>
<p>技术人攻略：去年的 Qcon China 上，您谈到了敏捷的腐化和到底什么是敏捷，有没有哪些软件项目领域，是敏捷开发模式不适用的？</p>
</blockquote>
<p>你的问题认为，“敏捷” 是一种东西。</p>
<p>真相是，“敏捷” 并不存在。它不是一种 “东西”，不是一个名词。人们是把它当成一个名词开始用起来的，但是他们并不理解背后的含义。</p>
<p>“敏捷” 不是一种东西，敏捷是一个形容词——它描述了一种东西。你可能有一个敏捷的团队，或者一种敏捷的过程，但你却从来不是 “敏捷”。</p>
<p>这是什么意思？这意味着那些向你硬推 “敏捷” 这个名词的人在撒谎，因为 “敏捷” 是买不来的。</p>
<p>相反，敏捷是因人而起的——它来自于那些希望把事情做得更好的个体。这些个体观察如何做事，并寻找改进事情的方法。Kent Beck 说这需要勇气，他说得没错。每当你尝试做出改进，你都在尝试改变现状，你将直面风险，你挑战了那些和你共事的人，他们也会用挑战来回敬你。</p>
<p>但是，我认为：在任何环境下，这些挑战和相关的讨论都是合适的。</p>
<blockquote>
<p>技术人攻略：您接触过中国的程序员吗？您觉得他们和西方的程序员有哪些区别？</p>
</blockquote>
<p>我喜欢来中国的原因之一，就是可以和这里的程序员交流。</p>
<p>这次的中国之行，我们在一家创业孵化咖啡馆（注：车库咖啡）渡过了非常愉快的一段时光。大家的活力和热情让我和我的妻子非常震惊，她甚至还为此写了一一篇博客。</p>
<p>西方的程序员也拥有这样的热情，但我在中国遇到的程序员表现出更多东西。或许是因为中国程序员要在更困难的环境下工作，又或许是因为中国的市场正开始爆发。不管是因为什么，我总能从中国程序员身上感到更多能量。</p>
<p>中国同时还有另外一类程序员，我在和他们谈话的过程中注意到，他们把工作当成任务。或许在家庭的推动下进入这个可以获得一份 “好” 工作的行业，或许想在一个大型机构里寻求安全感。不管是出于什么原因，这类程序员身上都缺乏激情，缺少一份对他们所作事情的热爱。这令人伤心，因为写程序真的是一件非常有成就感，非常让人满足的事。我建议这些程序员们看看我妻子的那篇博客上的照片，问问自己是否也愿意加入其中，是否愿意向桌子对面的人分享自己的新想法？<br>他们可以做到——任何人都可以做到。</p>
<p>采访时间：2013 年 11 月 7 日</p>
<h2 id="u9644_uFF1ADave_Thomas__u59BB_u5B50_u7684_u535A_u5BA2_u6587_u7AE0_u2014_u2014The_Future"><a href="#u9644_uFF1ADave_Thomas__u59BB_u5B50_u7684_u535A_u5BA2_u6587_u7AE0_u2014_u2014The_Future" class="headerlink" title="附：Dave Thomas 妻子的博客文章——The Future"></a>附：Dave Thomas 妻子的博客文章——The Future</h2><p>晚餐过后，大会组织者将我们带到了一个创业孵化器——一家大型的互联网咖啡馆，年轻的中国技术创业者们在这里工作、和投资人会面、推销想法、编写代码——这些事情都同时进行。这一切简直是太赞了！星期天晚上的 11 点，我们走进了这个灯光昏暗、大堂几乎没有家具的路边办公室。穿过后门，上了楼梯，直接加入了充满创业热情的人群。我们比房间里的人年长得多，他们有着令人惊叹的能量，几乎所有的人都在参与创业项目。他们出来聊天，碰撞想法，并马上付诸实践。Dave 被包围了，起先，我以为他们是在寻求某种投资。但并不是——我彻底错了。我们听到，并不断听到，想投资他们的人比他们需要的多得多。他们想了解 Dave 对自己创业项目的看法，他的祝福和他的批评——他们十分投入，期待成功。他们想有所成就，而且他们每个人都有非常棒的，独特的事业。</p>
<p>在一个角落里有一台 3D 打印机——正在做一个脊椎。另一个大的角落作为演示区域，配置好了笔记本的投影。后面的墙上是一组技术书架（他们向我们保证，有许多 Pragmatic 出版的书）。这里的环境是随性而自然的——桌椅随意摆放，人们可以根据讨论需求随意组合。</p>
<p>这些年轻人了解各个层面的知识，不仅仅是技术上的。他们理解在开曼群岛上注册公司、天使投资以及 IPO，3D 打印机旁的电脑连着 Kickstarter。这些人聪明、热情，并且很努力，一点也看不到懒惰、傲慢以及理所当然的态度。<br>还有来自香港和台湾的年轻人，他们认为中国大陆才是做事的地方。</p>
<p>我对此毫不怀疑——他们说得很对。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个信息爆炸的移动互联网时代，我们身边总会有一些技术圈的大牛出现，介绍他们的文章大多是以技术角度，描述他们的作品多么牛逼，而我们往往除了膜拜也无从知晓这些技术人的成长经历。</p>
<p>带着写一些「有趣」的技术人故事的初心，《技术人创业攻略》的作者张兰开始了她的乌托邦式]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈程序员的软技能]]></title>
    <link href="http://blog.devtang.com/2016/08/22/soft-skills/"/>
    <id>http://blog.devtang.com/2016/08/22/soft-skills/</id>
    <published>2016-08-22T13:49:52.000Z</published>
    <updated>2016-09-04T14:32:31.000Z</updated>
    <content type="html"><![CDATA[<p>最近读到一本有意思的书，叫：《软技能：代码之外的生存指南》，这是一本相当跨界的书，内容除了介绍了技术人的职业发展之外，还涉及了自我的营销、学习方法、生产力、健身、甚至还包括理财。应该说，每一个章节都是非常有意思的，值得每一个程序员学习的内容。</p>
<img src="/images/soft-skills-mindnode.jpg">
<p>《软技能》一书的内容分为以上这些章节，我也按这些章节讲讲自己的感悟吧。</p>
<h2 id="u804C_u4E1A"><a href="#u804C_u4E1A" class="headerlink" title="职业"></a>职业</h2><p>职业一章介绍了程序员的面试，晋升，离职，远程办公，自由职业，以及创业。不管做什么事情，专业性总是第一要点。就像书中写的那样，我们应该成为「专业人士」，这就要求我们对所做的工作始终精益求精。这其实与行业无关，职业精神在任何行业都应该俱备。</p>
<p>在程序员这个行业，我们的职业精神在于追求代码的美，这包括架构的可扩展，命名的规范，合理的注释，合理的设计模式。但其实，我们最最欠缺的职业精神是：按时发布产品。</p>
<p>我们总有无数的借口：未知的技术挑战，没有遇到过的 Bug，产品需求的变更，相关联调人员的问题，但是好的程序员，总是能够在各种风险发生时，通过自己的努力保持按时上线。</p>
<p>在这一点上，越是大公司的程序员，反倒由于大公司病的影响，职业精神就越差。</p>
<h2 id="u81EA_u6211_u8425_u9500"><a href="#u81EA_u6211_u8425_u9500" class="headerlink" title="自我营销"></a>自我营销</h2><p>100 个程序员里面，有 99 个不会营销，这还是乐观的说法。而我就是那个稍微会点营销的人，我从中享受到的红利已经多得超过我实际的付出了，弄得我自己都不好意思。我常常给别人说，我不是大牛，我只是喜欢分享而已。不过话说回来，一般喜欢分享的人水平都差不到哪儿去，为什么呢？因为他如果分享的内容有问题，就会被人指出来，那么他就会很快得到纠正。他如果分享的内容没问题，就会被高手看到找上门来交流，那么他就多了一个高水平的相互学习讨论的人。所以对于分享者来说，分享行为总是好事。</p>
<p>在中国如何做自我营销呢？基本上做到两点就可以了：</p>
<ol>
<li>写技术博客。</li>
<li>发技术微博。</li>
</ol>
<p>写技术博客好难啊怎么办？可以从翻译国外博客开始。发技术微博好难啊怎么办？可以从转发技术微博开始。看看 JSPatch 的作者 bang，人家从 10 年前就写博客了，能写不好吗？</p>
<p>切忌把时间花在混各种圈子，包括 QQ 群、微信群、各种技术论坛，这对自我营销效果基本没有，而且还很花费时间。</p>
<h2 id="u5B66_u4E60"><a href="#u5B66_u4E60" class="headerlink" title="学习"></a>学习</h2><p>很多人问我：「唐巧，我参加完培训班找不到工作怎么办啊」，因为移动互联网的泡沫，今年 iOS 新人太多，我也不知道怎么办，但是学习肯定不是参加完培训班就结束了的。</p>
<p>程序员必须具备自我学习的能力，而自我学习的能力第一步，就是书中第 27 章讲的「学习如何学习」，我们把它叫做元学习吧。一个学习者，应该俱备一种通用能力，就是遇到一个新知识的时候，能够有一套方法，能够迅速地学习掌握这门新知识。</p>
<p>在这个快速变化的时代，编程语言以及开发生态都在不停迭代升级，像 iOS 开发更是经历着从 Objective-C 向 Swift 的巨大迁移。处于时代中心的我们，没有元学习能力，如何获得竞争力？难道你工作之后，还要给企业老板说：我要请三个月假报一个培训班，学习 Swift ？</p>
<p>回到刚刚说到的问题，如果你参加完培训班找不到工作，只有更加努力地多积累 iOS 开发知识，尝试让自己的能力变得更强，可以尝试自己接个外包，或者自己写一些开源组件，或者找一份实习，都是一些可能的方法。iOS 新人的市场竞争非常激烈，除了自己比别人花更多时间和精力之外，没有什么捷径。</p>
<h2 id="u751F_u4EA7_u529B"><a href="#u751F_u4EA7_u529B" class="headerlink" title="生产力"></a>生产力</h2><p>作者介绍了许多办法提供自己的工作效率，里面也提到了我以前介绍过的 <a href="/2016/04/12/tomato-time-management/">番茄工作法</a>。</p>
<p>我自己对于生产力的理解在前两天的 <a href="/2016/07/20/programming-worlds-farmer-and-god/">《软件开发中的上帝模式与农民模式》</a> 文章中也提到了，效率方面的生产力，其实都是提升自己的农民模式。</p>
<p>本书中提到的任务分解，计时，培养习惯都是不错的实践方法。</p>
<h2 id="u7406_u8D22"><a href="#u7406_u8D22" class="headerlink" title="理财"></a>理财</h2><p>本章中我们看到了一个外国程序员对于买房和期权的理解。我个人感觉和中国的国情还是有一些差距。</p>
<p>在中国，我和小伙伴们在过去 5 年中很遗憾地发现，工资还没有房价涨得快。身边好几个朋友经历了自己买的房子暴涨几百万的情况，还是挺吓人的。</p>
<p>期权方面，国内的国情和国外也不一样，小道信息的作者 Fenng 最近似乎也在这方面遭遇了一些困惑，我其实之前也在这方面遇到一些问题。关于期权，稍后我也会另外撰文分享我的观点。</p>
<h2 id="u5065_u8EAB"><a href="#u5065_u8EAB" class="headerlink" title="健身"></a>健身</h2><p>有人说程序员是最适合当老公的，因为社会关系简单，薪水高，死得早。。。。</p>
<p>健身这件事情被无数人挂在嘴边，却坚持不下来。其实这件事情还是看个人对于延迟满足感的控制，像我前段时间，就坚持了四个月健身，不但学会了自由泳，而且达到了一次游 1000 米。我现在 1000 米的成绩是 29 分钟，我打算继续坚持下去，每个月减少 1 分钟。</p>
<h2 id="u7CBE_u795E"><a href="#u7CBE_u795E" class="headerlink" title="精神"></a>精神</h2><p>作者在本章中讲了一些积极的人生观，嗯，其实就是鸡汤。身子虚的同学可以补补。</p>
<h2 id="u6700_u540E_uFF08_u6D3B_u52A8_u5DF2_u7ED3_u675F_uFF09"><a href="#u6700_u540E_uFF08_u6D3B_u52A8_u5DF2_u7ED3_u675F_uFF09" class="headerlink" title="最后（活动已结束）"></a>最后（活动已结束）</h2><p>送书活动来啦，为了庆祝人民邮件出版社异步社区成立一周年，iOS 开发与异步社区联合发起评论赠书活动。</p>
<p>赠书规则如下：评论留下你关于软技能的想法，我将从评论的读者中选出 5 位读者赠送此书。</p>
<p>本次活动最终获奖的是：Thank立言、Julin、yeafel、OSong、破船。选择他们的理由包括：留言质量较高、经常与我互动留言（微信后台现在可以查到大家的互动次数）。奖品有限，希望没有获得的小伙伴别在意～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近读到一本有意思的书，叫：《软技能：代码之外的生存指南》，这是一本相当跨界的书，内容除了介绍了技术人的职业发展之外，还涉及了自我的营销、学习方法、生产力、健身、甚至还包括理财。应该说，每一个章节都是非常有意思的，值得每一个程序员学习的内容。</p>
<img src="/]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[小青和他的 RxSwift 课程]]></title>
    <link href="http://blog.devtang.com/2016/08/13/xiaoqing-and-rxswfit-course/"/>
    <id>http://blog.devtang.com/2016/08/13/xiaoqing-and-rxswfit-course/</id>
    <published>2016-08-13T03:31:11.000Z</published>
    <updated>2016-08-13T03:31:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xil0e.com1.z0.glb.clouddn.com/teacher/57908b8961854.png" alt=""></p>
<p>第一次认识小青（<a href="http://weibo.com/u/2314535081" target="_blank" rel="external">@靛青K</a>），是在他与梁杰一起创办的 <a href="http://t.swift.gg/" target="_blank" rel="external">T 沙龙</a>聚会上。当时小青邀请到了代码家，给大家介绍了函数式编程的一些内容。T 沙龙的模式很有意思，它强调纯线下的、小范围的、免费的交流。这与现在这个强调规模与经济的互联网时代格格不入，但是不可否认的是，小青和梁杰办得很成功。就在上一次分享会中，小青邀请到了 <a href="http://weibo.com/u/2157980617" target="_blank" rel="external">@txx</a> 和 h4x 为大家分享逆向，特别是 txx 现象从头到尾演示一个 App 被逆向的过程让我对逆向的实践有了更多的了解。</p>
<p>沙龙的茶歇期间的闲聊，我才了解到小青还未大学毕业，但是他已经在 Enjoy 开始了他的第二份实习，而这份实习中，他将会用 RxSwift 重构 Enjoy 的众多模块。我私下问他为什么选择 Enjoy，他毫不犹豫地说：「因为可以用 RxSwift 呀！」。其实这也从一个侧面反映出，业界对于 RxSwift 以及比 RxSwift 更早的 ReactiveCocoa 都处于观望的心态，真正勇于尝试的并不多。</p>
<p>为了学习和推广 RxSwift，小青也花了大量的精力，比如他发布了大量 RxSwift 的教程在 <a href="http://t.swift.gg/t/rxswift-course" target="_blank" rel="external">SwiftGG网站</a>  和<a href="https://medium.com/@DianQK" target="_blank" rel="external">他的博客</a> 上。今年初，小青也成为了 GMTC 2016 全球移动技术大会 Swift 专场讲师，为大家分享了 RxSwift。另外他也在编写一本 RxSwift 的书，预计年底将会出版。</p>
<p>与此同时，小青也在 StuQ 开设了一门 RxSwift 在线直播小班课，这个课程当前处于报名阶段，预计 8 月下旬开课。这个在线直播课程限 60 人，感兴趣的同学可以查看这里的<a href="http://www.stuq.org/my/courses/study/1062" target="_blank" rel="external">详细介绍</a>，你可以说这是一个广告，也可以说这是一个推荐，反正我自己是报名了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xil0e.com1.z0.glb.clouddn.com/teacher/57908b8961854.png" alt=""></p>
<p>第一次认识小青（<a href="http://weibo.com/u/2314535081"]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈 T 型人才]]></title>
    <link href="http://blog.devtang.com/2016/08/13/talk-about-full-stack/"/>
    <id>http://blog.devtang.com/2016/08/13/talk-about-full-stack/</id>
    <published>2016-08-13T03:10:25.000Z</published>
    <updated>2016-08-13T03:11:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u300C_u5168_u6808_u300D_u5DE5_u7A0B_u5E08"><a href="#u300C_u5168_u6808_u300D_u5DE5_u7A0B_u5E08" class="headerlink" title="「全栈」工程师"></a>「全栈」工程师</h2><p>前一段时间，「全栈」工程师的概念很火，不过大多数时候，「全栈」工程师指的是一个人同时写 Web 前端和后端，顶多加上一些运维工作。通常情况下，我很少见到一个人能够同时写 Web 前端 + 后端 +iOS 端 +Android 端。</p>
<p>在猿题库（我们现在改名叫猿辅导了）创业初期，我曾经试图同时写 iOS 和服务器端，但是我很快就放弃了。因为当时服务器端的代码量还是很大，同时有好几个人在编写。有些时候我需要加逻辑时，会涉及到他们的代码修改，这个时候我就会需要花费额外的精力来看懂他们原来的逻辑。</p>
<p>当时正值创业初期，我们的 Code Review 并不严格，代码的相关设计文档也不多，我只能通过阅读源码来跟上另外几个服务器端开发同学的逻辑。很快我就放弃了，因为在创业阶段，效率是第一位的，同时做 iOS 和 服务器端，使得我在服务器端不够专注，效率变得低下。</p>
<p>从那之后，我就意识到，「全栈」工程师可能最适合的场景就是 Web 前端 + 后端的偏前端的逻辑。因为那个场景下，前端工程师可以省掉沟通接口的时间，也可以自己统一前后端的模版，甚至他可以尝试统一语言，同时用 JavaScript 写前后端（在后端使用 nodejs）。</p>
<p>而在别的职位上，是很不适合全栈的，因为这样工作产出会下降。</p>
<h2 id="T__u578B_u4EBA_u624D"><a href="#T__u578B_u4EBA_u624D" class="headerlink" title="T 型人才"></a>T 型人才</h2><p>那我为什么又想聊 T 型人才呢？是因为我觉得 T 型人才和全栈不一样。在我看来，T 型人才有一门自己擅长和精通的语言，同时又有足够宽的视野，使得他在合作的时候，能够更多地站在对方的立场上考虑问题。</p>
<p>打个比方，做过服务器端开发的同学，再转而做客户端开发，就会更加注意 Restful 接口的设计合理性。相互之间协商接口时，知道什么样的方式服务器端好实现，什么样的方式不好实现，然后定出来的接口就会让对方非常舒适。</p>
<p>与此同时，T 型人才对于自己理解和学习新东西，也是有很大帮助的。我之前做过 Java 语言的服务器端开发和 JavaScript 语言的前端开发，之后才转做 iOS 开发。各种语言和开发环境接触多了就发现：其实很多概念都是相通的。我想我之所以当时学 iOS 开发上手那么快，也是由于在别的语言上有积累。</p>
<p>其实对于移动开发来说，iOS 和 Android 也有很多相同的概念，比如 iOS 的 UIViewController 和 Android 的 Activity。当然，它们也有很多不同的技术细节，比如对界面排版设计，iOS 因为设备屏幕单一，所以刚开始选择了简单的绝对定位，后面选择了 size class 的方式。而 Android 因为屏幕分裂严重，所以选择了更加流式的排版设计。</p>
<p>iOS 因为追求界面的流畅和性能，选择了引用计数这种相对麻烦的内存管理方式，而 Android 因为需要借力 Java 语言本身的生态和苹果竞争，所以采用了垃圾回收这种会带来潜在卡顿风险的内存管理方式。<br>每年的 Google IO 大会出现的新技术，并不比 WWDC 逊色。今年 iOS 10 的一些改进，也看到了不少 Android 的影子。</p>
<h2 id="u5982_u4F55_u6210_u4E3A_T__u578B_u4EBA_u624D"><a href="#u5982_u4F55_u6210_u4E3A_T__u578B_u4EBA_u624D" class="headerlink" title="如何成为 T 型人才"></a>如何成为 T 型人才</h2><p>那么如何成为 T 型人才呢？我们老大郭常圳想了一个办法：轮岗。轮岗的意思是，当你成为某一方面的专家后，跳出自己的舒适区，转而到一个新的技术领域从头学起。</p>
<p>在我们公司，很多早期员工都经历过轮岗。比如我曾经从服务器端转到前端和 iOS 端，也是轮岗这个激励带动的。yangyz 从服务器端转到 Android，xuhf 从 Android 转到服务器端，zhangyc 从 Web 前端转到后端。每一个轮岗工作，都是对我们极大的挑战，但是让我们都成长为 T 型人才。</p>
<p>但是，轮岗的意思绝不是做一个技术方向「三心二意」，每一次转换技术方向，都应该是对前一个技术方向至少做到熟练掌握的程度才行，而我自己觉得，不经过一到两年的实践，很难称作熟练掌握。所以，轮岗的行为应该是低频的，而且是面向那些最优秀的开发者的。</p>
<p>这一点有点像大学的换专业，在我们学校，大一的学生可以在一学期后申请换专业，但是前提是这个同学在愿专业成绩达到前 10%。</p>
<p>换专业和换技术方向一样，机会只会给做得最好的人，公司不会因为一个人在 iOS 开发上做得不好，就把他轮换到别的开发岗位。</p>
<h2 id="u521B_u4E1A_u521D_u671F"><a href="#u521B_u4E1A_u521D_u671F" class="headerlink" title="创业初期"></a>创业初期</h2><p>在创业初期，很多时候技术创始团队由于缺人，每个人都是多面手。上次一个朋友说，他自己完全了服务器和网站的开发，然后又自己开发了 iOS 和 Android 端，实现了真正的「全栈」。</p>
<p>对此，我完全不否认有这样的人存在，而且我认为创业初期这么做也是完全合理的。因为创业初期重要的是做出东西，而招不到人的情况下，自己动手干是最简单直接的方式。</p>
<p>我想我更想表达的是一个词：效率。举个例子，假如这个创业公司做大了，变成 20 人的技术团队时，你会让每个人都同时做服务器，iOS，Android 开发呢，还是每个人只做某一方面？我想从效率上讲，每个人只做某一个具体的平台，效率是最大化的。这其实就是我想表达的，「全栈」工程师在理想情况下，并不是高效运作的公司期望的，只有某些特别情况下，「全栈」才有它存在的理由。</p>
<p>但是反过来，T 型人才是每个公司都期望拥有的，因为这样的人才视野更广，学习能力更强，沟通时会从对方角度考虑技术方案，甚至在某些技术方向没落之后，也会迅速地成功转型，这才是互联网公司理想的人才。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u300C_u5168_u6808_u300D_u5DE5_u7A0B_u5E08"><a href="#u300C_u5168_u6808_u300D_u5DE5_u7A0B_u5E08" class="headerlink" title="「全栈」工程师"><]]>
    </summary>
    
      <category term="startup" scheme="http://blog.devtang.com/tags/startup/"/>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何用 Git 将代码恢复到一个历史的版本]]></title>
    <link href="http://blog.devtang.com/2016/08/06/revert-to-target-commit-with-git/"/>
    <id>http://blog.devtang.com/2016/08/06/revert-to-target-commit-with-git/</id>
    <published>2016-08-06T09:39:43.000Z</published>
    <updated>2016-08-09T07:37:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u9700_u6C42"><a href="#u9700_u6C42" class="headerlink" title="需求"></a>需求</h2><p>有些时候，在一些特殊情况下，我们需要将代码恢复到一个历史的提交版本上。而这个历史提交版本，离最新的提交已经比较久远了。</p>
<p>比如，我希望将如下的仓库的提交，恢复到上上上上次提交。当然，我可以一次一次的 revert，但是有没有更快更简单的办法呢？</p>
<img src="/images/git-revert-1.jpg">
<h2 id="u66B4_u529B_u7684_u65B9_u5F0F"><a href="#u66B4_u529B_u7684_u65B9_u5F0F" class="headerlink" title="暴力的方式"></a>暴力的方式</h2><p>如果你的仓库是自己在用（不影响别人），那么你可以使用 <code>git reset --hard &lt;target_commit_id&gt;</code> 来恢复到指定的提交，再用 <code>git push -f</code> 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。</p>
<p>对于刚刚的例子，需要执行的命令就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#22791;&#20221;&#24403;&#21069;&#30340;&#20998;&#25903;&#21040; backup_commit&#10;git tag backup_commit&#10;git push origin backup_commit&#10;// &#37325;&#32622; source &#20998;&#25903;&#10;git reset --hard 23801b2&#10;// &#24378;&#21046; push &#26356;&#26032;&#36828;&#31243;&#20998;&#25903;&#10;git push origin source -f</span><br></pre></td></tr></table></figure>
<h2 id="u6E29_u548C_u7684_u65B9_u5F0F"><a href="#u6E29_u548C_u7684_u65B9_u5F0F" class="headerlink" title="温和的方式"></a>温和的方式</h2><p>如果你的仓库是多人在协作，那么你这么操作会使用别人本地的代码库混乱，所以只能建一个新的提交，这个新的提交中把想取消的提交都 revert 掉，那么具体应该如何做呢？方法如下：</p>
<p>首先，和刚刚一样，用 <code>git reset --hard 23801b2</code> 将代码切换到目标提交的 id。接下来，用 <code>git reset --soft origin/source</code> 命令，将当前代码切换回最新的提交。</p>
<p>执行完上面两步后，你的仓库还是最新的提交，但是工作区变成了历史的提交内容，这个时候用 <code>git add</code> 和 <code>git commit</code> 即可。最终完成的效果如下：</p>
<img src="/images/git-revert-2.jpg">
<p>不过经过念茜的提醒，该方法需要保证 reset 的时候没有别人做新的提交，如果有的话，会一并把别人的提交也撤销了。所以还是挺危险的，慎用。</p>
<p>虽然用到的时候很少，但是理解它的原理有助于大家理解 Git 的工作区，暂存区和版本库的各种指针操作的意义，希望对大家有用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9700_u6C42"><a href="#u9700_u6C42" class="headerlink" title="需求"></a>需求</h2><p>有些时候，在一些特殊情况下，我们需要将代码恢复到一个历史的提交版本上。而这个历史提交版本，离最新的提交已]]>
    </summary>
    
      <category term="Git" scheme="http://blog.devtang.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么不喜欢 Core Data]]></title>
    <link href="http://blog.devtang.com/2016/08/04/i-do-not-like-core-data/"/>
    <id>http://blog.devtang.com/2016/08/04/i-do-not-like-core-data/</id>
    <published>2016-08-04T14:47:06.000Z</published>
    <updated>2016-08-07T09:19:41.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/core-data-head.jpg">
<p>我一直不喜欢 Core Data，以前不太敢明目张胆地这么表达，现在收集到越来越多相关的信息，所以给大家分享一下，我为什么不喜欢 Core Data。</p>
<h2 id="Core_Data__u592A_u590D_u6742"><a href="#Core_Data__u592A_u590D_u6742" class="headerlink" title="Core Data 太复杂"></a>Core Data 太复杂</h2><p>在今年刚刚结束的 <a href="http://gmtc.geekbang.org/" target="_blank" rel="external">GMTC 大会</a>上，来自澳洲的李剑做了题为《iOS 遗留系统上的架构重构》的演讲，其中就提到 Core Data 给他们 500 万用户带来了 300 万次崩溃。我想任何产品都是不能接受这样的崩溃率的。</p>
<p>这 300 万次崩溃是 Core Data 的问题吗？可能也不是。在现场我没有看到具体的代码细节，我更觉得这可能是 Core Data 在使用中的各种坑，需要大家注意避免的。但是 Core Data 的坑是如此之多，使得像李剑这样的资深 iOS 开发者也不得不考虑将其直接替换掉。一个好的技术框架应该是不容易出现使用错误的，所以从这个角度讲，Core Data 本身的设计就是不好的。</p>
<h2 id="Core_Data__u5B66_u4E60_u6210_u672C_u9AD8"><a href="#Core_Data__u5B66_u4E60_u6210_u672C_u9AD8" class="headerlink" title="Core Data 学习成本高"></a>Core Data 学习成本高</h2><p>很多人觉得 Core Data 简单易学，我听了简直觉得自己的智商得到了 1 万点的伤害。反正我学习 Core Data 那阵子，Core Data 的各种概念着实让我郁闷了好久。在 OhMyStar 的作者 yu 的博客<a href="http://www.iiiyu.com/2016/01/19/CoreData-VS-Realm/" target="_blank" rel="external">文章</a>上，yu 这么写道：</p>
<blockquote>
<p>CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。<br>CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。<br>CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。</p>
<p>如果没有足够的时间和精力去接入 Core Data。 那选型的时候应当慎重考虑。</p>
</blockquote>
<p>我想那些觉得 Core Data 很简单的人，可能更多时候是自己学了一点皮毛，就以为懂了全部吧。反正我是学不会 Core Data。</p>
<h2 id="Core_Data__u7684_u6536_u76CA_u5E76_u4E0D_u5927"><a href="#Core_Data__u7684_u6536_u76CA_u5E76_u4E0D_u5927" class="headerlink" title="Core Data 的收益并不大"></a>Core Data 的收益并不大</h2><p>如果一门技术方案学习成本高，那么我们有动力继续学习的它的唯一理由就是：它的收益也非常大。但是，Core Data 在各种性能测试中，表现出<br>来的收益是相当差的。在这一点上，Realm 是最喜欢拿来说事的，拿查阅来说，Core Data 的性能是 FMDB 的六分之一不到，Realm 的十分之一不到。</p>
<img src="/images/coredata-vs-realm.jpg">
<p>Core Data 带来的另外的特性：例如可视化的编辑界面，关联关系的创建，数据库升级的支持，我个人觉得都不是非常大的收益。相对它带来的麻烦，这些收益微不足道。</p>
<h2 id="Core_Data__u7684_u8FD9_u5C42_u62BD_u8C61_u6CA1_u5FC5_u8981"><a href="#Core_Data__u7684_u8FD9_u5C42_u62BD_u8C61_u6CA1_u5FC5_u8981" class="headerlink" title="Core Data 的这层抽象没必要"></a>Core Data 的这层抽象没必要</h2><p>其实 Core Data 是构建在 SQLite 之上，对数据存储层进行了进一步的抽象。而我个人认为，对于一个计算机专业的人员来说，掌握 SQL 就像掌握 BASIC 一样容易，关系型数据库实在太容易理解了，完全没有必要在这上面再做一层抽像，带来额外的理解成本。</p>
<p>所以我更喜欢用 FMDB，它只是将 SQLite 的一些方法进行了 Objective-C 语言更加友好的调用封装，除此之外，你就完全是在操作一个 SQLite 数据库。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>使用复杂，学习复杂，坑多，收益小成本大，基本没有意义的抽象，我们还有什么理由继续学习和使用 Core Data ？</p>
<p>哦，对了，我也不喜欢  Realm，有机会下次再说它。</p>
<p>对于我来说，FMDB 以及构建在 FMDB 上的简单的 Key-Value 存储就足够了。我之前在 GitHub 开源过一个简单的基于 FMDB 的 KeyValue 存储 <a href="https://github.com/yuantiku/YTKKeyValueStore" target="_blank" rel="external">YTKKeyValueStore</a>，感兴趣的可以翻翻。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/core-data-head.jpg">
<p>我一直不喜欢 Core Data，以前不太敢明目张胆地这么表达，现在收集到越来越多相关的信息，所以给大家分享一下，我为什么不喜欢 Core Data。</p>
<h2 id="Core_Data_]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解 iOS 的内存管理]]></title>
    <link href="http://blog.devtang.com/2016/07/30/ios-memory-management/"/>
    <id>http://blog.devtang.com/2016/07/30/ios-memory-management/</id>
    <published>2016-07-30T00:43:42.000Z</published>
    <updated>2016-07-30T01:02:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u8FDC_u53E4_u65F6_u4EE3_u7684_u6545_u4E8B"><a href="#u8FDC_u53E4_u65F6_u4EE3_u7684_u6545_u4E8B" class="headerlink" title="远古时代的故事"></a>远古时代的故事</h2><p>那些经历过手工管理内存（MRC）时代的人们，一定对 iOS 开发中的内存管理记忆犹新。那个时候大约是 2010 年，国内 iOS 开发刚刚兴起，tinyfool 大叔的大名已经如雷贯耳，而我还是一个默默无闻的刚毕业的小子。那个时候的 iOS 开发过程是这样的：</p>
<blockquote>
<p>我们先写好一段 iOS 的代码，然后屏住呼吸，开始运行它，不出所料，它崩溃了。在 MRC 时代，即使是最牛逼的 iOS 开发者，也不能保证一次性就写出完美的内存管理代码。于是，我们开始一步一步调试，试着打印出每个怀疑对象的引用计数（Retain Count），然后，我们小心翼翼地插入合理的 <code>retain</code> 和 <code>release</code> 代码。经过一次又一次的应用崩溃和调试，终于有一次，应用能够正常运行了！于是我们长舒一口气，露出久违的微笑。</p>
</blockquote>
<p>是的，这就是那个年代的 iOS 开发者，通常情况下，我们在开发完一个功能后，需要再花好几个小时，才能把引用计数管理好。</p>
<p>苹果在 2011 年的时候，在 WWDC 大会上提出了自动的引用计数（ARC）。ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员。</p>
<p>在 ARC 刚刚出来的时候，业界对此黑科技充满了怀疑和观望，加上现有的 MRC 代码要做迁移本来也需要额外的成本，所以 ARC 并没有被很快接受。直到 2013 年左右，苹果认为 ARC 技术足够成熟，直接将 macOS（当时叫 OS X）上的垃圾回收机制废弃，从而使得 ARC 迅速被接受。</p>
<p>2014 年的 WWDC 大会上，苹果推出了 Swift 语言，而该语言仍然使用 ARC 技术，作为其<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" target="_blank" rel="external">内存管理方式</a>。</p>
<p>为什么我要提这段历史呢？就是因为现在的 iOS 开发者实在太舒服了，大部分时候，他们根本都不用关心程序的内存管理行为。但是，<strong>虽然 ARC 帮我们解决了引用计数的大部分问题，一些年轻的 iOS 开发者仍然会做不好内存管理工作</strong>。他们甚至不能理解常见的循环引用问题，而这些问题会导致内存泄漏，最终使得应用运行缓慢或者被系统终止进程。</p>
<p>所以，我们每一个 iOS 开发者，需要理解引用计数这种内存管理方式，只有这样，才能处理好内存管理相关的问题。</p>
<h2 id="u4EC0_u4E48_u662F_u5F15_u7528_u8BA1_u6570"><a href="#u4EC0_u4E48_u662F_u5F15_u7528_u8BA1_u6570" class="headerlink" title="什么是引用计数"></a>什么是引用计数</h2><p>引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 Objective-C 和 Swift 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。</p>
<img src="/images/memory-ref-count.png">
<p>为了更形象一些，我们再来看一段 Objective-C 的代码。新建一个工程，因为现在默认的工程都开启了自动的引用计数 ARC（Automatic Reference Count)，我们先修改工程设置，给 AppDelegate.m 加上 <code>-fno-objc-arc</code> 的编译参数（如下图所示），这个参数可以启用手工管理引用计数的模式。</p>
<img src="/images/memory-fno-objc-arc.png">
<p>然后，我们在中输入如下代码，可以通过 Log 看到相应的引用计数的变化。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </span><br><span class="line">       didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    <span class="built_in">NSObject</span> *another = [object retain];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [another release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="comment">// 到这里时，object 的内存被释放了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reference Count = 1&#10;Reference Count = 2&#10;Reference Count = 1</span><br></pre></td></tr></table></figure>
<p>对 Linux 文件系统比较了解的同学可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 <code>ln</code> 命令可以创建一个硬链接（相当于我们这里的 retain)，当删除一个文件时（相当于我们这里的 release)，系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。</p>
<h2 id="u6211_u4EEC_u4E3A_u4EC0_u4E48_u9700_u8981_u5F15_u7528_u8BA1_u6570"><a href="#u6211_u4EEC_u4E3A_u4EC0_u4E48_u9700_u8981_u5F15_u7528_u8BA1_u6570" class="headerlink" title="我们为什么需要引用计数"></a>我们为什么需要引用计数</h2><p>从上面那个简单的例子中，我们还看不出来引用计数真正的用处。因为该对象的生命期只是在一个函数内，所以在真实的应用场景下，我们在函数内使用一个临时的对象，通常是不需要修改它的引用计数的，只需要在函数返回前将该对象销毁即可。</p>
<p>引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。我们举一个具体的例子：</p>
<p>假如对象 A 生成了一个对象 M，需要调用对象 B 的某一个方法，将对象 M 作为参数传递过去。在没有引用计数的情况下，一般内存管理的原则是 “谁申请谁释放”，那么对象 A 就需要在对象 B 不再需要对象 M 的时候，将对象 M 销毁。但对象 B 可能只是临时用一下对象 M，也可能觉得对象 M 很重要，将它设置成自己的一个成员变量，那这种情况下，什么时候销毁对象 M 就成了一个难题。</p>
<img src="/images/memory-talk-1.png">
<p>对于这种情况，有一个暴力的做法，就是对象 A 在调用完对象 B 之后，马上就销毁参数对象 M，然后对象 B 需要将参数另外复制一份，生成另一个对象 M2，然后自己管理对象 M2 的生命期。但是这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作。本来一个可以复用的对象，因为不方便管理它的生命期，就简单的把它销毁，又重新构造一份一样的，实在太影响性能。如下图所示：</p>
<img src="/images/memory-talk-2.png">
<p>我们另外还有一种办法，就是对象 A 在构造完对象 M 之后，始终不销毁对象 M，由对象 B 来完成对象 M 的销毁工作。如果对象 B 需要长时间使用对象 M，它就不销毁它，如果只是临时用一下，则可以用完后马上销毁。这种做法看似很好地解决了对象复制的问题，但是它强烈依赖于 AB 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于对象 M 的申请是在对象 A 中，释放在对象 B 中，使得它的内存管理代码分散在不同对象中，管理起来也非常费劲。如果这个时候情况再复杂一些，例如对象 B 需要再向对象 C 传递对象 M，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方式带来的复杂性更大，更不可取。</p>
<img src="/images/memory-talk-3.png">
<p>所以引用计数很好的解决了这个问题，在参数 M 的传递过程中，哪些对象需要长时间使用这个对象，就把它的引用计数加 1，使用完了之后再把引用计数减 1。所有对象都遵守这个规则的话，对象的生命期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。</p>
<h2 id="u4E0D_u8981_u5411_u5DF2_u7ECF_u91CA_u653E_u7684_u5BF9_u8C61_u53D1_u9001_u6D88_u606F"><a href="#u4E0D_u8981_u5411_u5DF2_u7ECF_u91CA_u653E_u7684_u5BF9_u8C61_u53D1_u9001_u6D88_u606F" class="headerlink" title="不要向已经释放的对象发送消息"></a>不要向已经释放的对象发送消息</h2><p>有些同学想测试当对象释放时，其 <code>retainCount</code> 是否变成了 0，他们的试验代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果你真的这么实验，你得到的输出结果可能是以下这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reference Count = 1&#10;Reference Count = 1</span><br></pre></td></tr></table></figure>
<p>我们注意到，最后一次输出，引用计数并没有变成 0。这是为什么呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。</p>
<p>那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？这是因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。</p>
<p>拿我们之前提到的 Linux 文件系统举列，Linux 文件系统下删除一个文件，也不是真正的将文件的磁盘区域进行抹除操作，而只是删除该文件的索引节点号。这也和引用计数的内存回收方式类似，即回收时只做标记，并不抹除相关的数据。</p>
<h2 id="ARC__u4E0B_u7684_u5185_u5B58_u7BA1_u7406_u95EE_u9898"><a href="#ARC__u4E0B_u7684_u5185_u5B58_u7BA1_u7406_u95EE_u9898" class="headerlink" title="ARC 下的内存管理问题"></a>ARC 下的内存管理问题</h2><p>ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外还有 10% 内存管理，是需要开发者自己处理的，这主要就是与底层 Core Foundation 对象交互的那部分，底层的 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。</p>
<p>对于 ARC 盲目依赖的 iOS 新人们，由于不知道引用计数，他们的问题主要体现在：</p>
<ol>
<li>过度使用 block 之后，无法解决循环引用问题。</li>
<li>遇到底层 Core Foundation 对象，需要自己手工管理它们的引用计数时，显得一筹莫展。</li>
</ol>
<h3 id="u5FAA_u73AF_u5F15_u7528_uFF08Reference_Cycle_uFF09_u95EE_u9898"><a href="#u5FAA_u73AF_u5F15_u7528_uFF08Reference_Cycle_uFF09_u95EE_u9898" class="headerlink" title="循环引用（Reference Cycle）问题"></a>循环引用（Reference Cycle）问题</h3><p>引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。</p>
<img src="/images/memory-cycle-1.png">
<p>不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。</p>
<img src="/images/memory-cycle-2.png">
<h3 id="u4E3B_u52A8_u65AD_u5F00_u5FAA_u73AF_u5F15_u7528"><a href="#u4E3B_u52A8_u65AD_u5F00_u5FAA_u73AF_u5F15_u7528" class="headerlink" title="主动断开循环引用"></a>主动断开循环引用</h3><p>解决循环引用问题主要有两个办法，第一个办法是我明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示：</p>
<img src="/images/memory-cycle-3.png">
<p>主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。例如在我开源的 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a> 网络库中，网络请求的回调 block 是被持有的，但是如果这个 block 中又存在对于 View Controller 的引用，就很容易产生从循环引用，因为：</p>
<ul>
<li>Controller 持有了网络请求对象</li>
<li>网络请求对象持有了回调的 block</li>
<li>回调的 block 里面使用了 <code>self</code>，所以持有了 Controller</li>
</ul>
<p>解决办法就是，在网络请求结束后，网络请求对象执行完 block 之后，主动释放对于 block 的持有，以便打破循环引用。相关的代码见：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// https://github.com/yuantiku/YTKNetwork/blob/master/YTKNetwork/YTKBaseRequest.m&#10;// &#31532; 147 &#34892;&#65306;&#10;- (void)clearCompletionBlock &#123;&#10;    // &#20027;&#21160;&#37322;&#25918;&#25481;&#23545;&#20110; block &#30340;&#24341;&#29992;&#10;    self.successCompletionBlock = nil;&#10;    self.failureCompletionBlock = nil;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存（这通常与具体的业务逻辑相关），所以这种解决方法并不常用，更常见的办法是使用弱引用 (weak reference) 的办法。</p>
<h3 id="u4F7F_u7528_u5F31_u5F15_u7528"><a href="#u4F7F_u7528_u5F31_u5F15_u7528" class="headerlink" title="使用弱引用"></a>使用弱引用</h3><p>弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。举个例子来说，两个 ViewController A 和 B，ViewController A 需要弹出 ViewController B，让用户输入一些内容，当用户输入完成后，ViewController B 需要将内容返回给 ViewController A。这个时候，View Controller 的 delegate 成员变量通常是一个弱引用，以避免两个 ViewController 相互引用对方造成循环引用问题，如下所示：</p>
<img src="/images/memory-cycle-4.png">
<h3 id="u5F31_u5F15_u7528_u7684_u5B9E_u73B0_u539F_u7406"><a href="#u5F31_u5F15_u7528_u7684_u5B9E_u73B0_u539F_u7406" class="headerlink" title="弱引用的实现原理"></a>弱引用的实现原理</h3><p>弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。</p>
<p>从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为：</p>
<ol>
<li>我们在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。</li>
<li>大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。</li>
<li>早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见<a href="/2013/05/18/goodbye-viewdidunload/">《再见，viewDidUnload方法》</a>。</li>
</ol>
<h3 id="u4F7F_u7528_Xcode__u68C0_u6D4B_u5FAA_u73AF_u5F15_u7528"><a href="#u4F7F_u7528_Xcode__u68C0_u6D4B_u5FAA_u73AF_u5F15_u7528" class="headerlink" title="使用 Xcode 检测循环引用"></a>使用 Xcode 检测循环引用</h3><p>Xcode 的 Instruments 工具集可以很方便的检测循环引用。为了测试效果，我们在一个测试用的 ViewController 中填入以下代码，该代码中的 <code>firstArray</code> 和 <code>secondArray</code> 相互引用了对方，构成了循环引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    NSMutableArray *firstArray = [NSMutableArray array];&#10;    NSMutableArray *secondArray = [NSMutableArray array];&#10;    [firstArray addObject:secondArray];&#10;    [secondArray addObject:firstArray];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 Xcode 的菜单栏选择：Product -&gt; Profile，然后选择 “Leaks”，再点击右下角的”Profile” 按钮开始检测。如下图</p>
<img src="/images/memory-instruments-1.jpg">
<p>这个时候 iOS 模拟器会运行起来，我们在模拟器里进行一些界面的切换操作。稍等几秒钟，就可以看到 Instruments 检测到了我们的这次循环引用。Instruments 中会用一条红色的条来表示一次内存泄漏的产生。如下图所示：</p>
<img src="/images/memory-instruments-2.jpg">
<p>我们可以切换到 Leaks 这栏，点击”Cycles &amp; Roots”，就可以看到以图形方式显示出来的循环引用。这样我们就可以非常方便地找到循环引用的对象了。</p>
<img src="/images/memory-instruments-3.png">
<h3 id="Core_Foundation__u5BF9_u8C61_u7684_u5185_u5B58_u7BA1_u7406"><a href="#Core_Foundation__u5BF9_u8C61_u7684_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Core Foundation 对象的内存管理"></a>Core Foundation 对象的内存管理</h3><p>下面我们就来简单介绍一下对底层 Core Foundation 对象的内存管理。底层的 Core Foundation 对象，在创建时大多以 XxxCreateWithXxx 这样的方式创建，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#21019;&#24314;&#19968;&#20010; CFStringRef &#23545;&#35937;&#10;CFStringRef str= CFStringCreateWithCString(kCFAllocatorDefault, &#8220;hello world&#34;, kCFStringEncodingUTF8);&#10;&#10;// &#21019;&#24314;&#19968;&#20010; CTFontRef &#23545;&#35937;&#10;CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&#34;ArialMT&#34;, fontSize, NULL);</span><br></pre></td></tr></table></figure>
<p>对于这些对象的引用计数的修改，要相应的使用 <code>CFRetain</code> 和 <code>CFRelease</code> 方法。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;// &#21019;&#24314;&#19968;&#20010; CTFontRef &#23545;&#35937;&#10;CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&#34;ArialMT&#34;, fontSize, NULL);&#10;&#10;// &#24341;&#29992;&#35745;&#25968;&#21152; 1&#10;CFRetain(fontRef);&#10;// &#24341;&#29992;&#35745;&#25968;&#20943; 1&#10;CFRelease(fontRef);</span><br></pre></td></tr></table></figure>
<p>对于 <code>CFRetain</code> 和 <code>CFRelease</code> 两个方法，读者可以直观地认为，这与 Objective-C 对象的 <code>retain</code> 和 <code>release</code> 方法等价。</p>
<p>所以对于底层 Core Foundation 对象，我们只需要延续以前手工管理引用计数的办法即可。</p>
<p>除此之外，还有另外一个问题需要解决。在 ARC 下，我们有时需要将一个 Core Foundation 对象转换成一个 Objective-C 对象，这个时候我们需要告诉编译器，转换过程中的引用计数需要做如何的调整。这就引入了<code>bridge</code>相关的关键字，以下是这些关键字的说明：</p>
<ul>
<li><code>__bridge</code>: 只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。</li>
<li><code>__bridge_retained</code>：类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法。</li>
<li><code>__bridge_transfer</code>：类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不再需要调用 CFRelease 方法。</li>
</ul>
<p>我们根据具体的业务逻辑，合理使用上面的 3 种转换关键字，就可以解决 Core Foundation 对象与 Objective-C 对象相对转换的问题了。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>在 ARC 的帮助下，iOS 开发者的内存管理工作已经被大大减轻，但是我们仍然需要理解引用计数这种内存管理方式的优点和常见问题，特别要注意解决循环引用问题。对于循环引用问题有两种主要的解决办法，一是主动断开循环引用，二是使用弱引用的方式避免循环引用。对于 Core Foundation 对象，由于不在 ARC 管理之下，我们仍然需要延续以前手工管理引用计数的办法。</p>
<p>在调试内存问题时，Instruments 工具可以很好地对我们进行辅助，善用 Instruments 可以节省我们大量的调试时间。</p>
<p>愿每一个 iOS 开发者都可以掌握 iOS 的内存管理技能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8FDC_u53E4_u65F6_u4EE3_u7684_u6545_u4E8B"><a href="#u8FDC_u53E4_u65F6_u4EE3_u7684_u6545_u4E8B" class="headerlink" title="远古时代的故事"><]]>
    </summary>
    
      <category term="iOS" scheme="http://blog.devtang.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[六个维度的理论和故事 - 读《管理 3.0》]]></title>
    <link href="http://blog.devtang.com/2016/07/24/management-30-summary/"/>
    <id>http://blog.devtang.com/2016/07/24/management-30-summary/</id>
    <published>2016-07-24T13:00:46.000Z</published>
    <updated>2016-07-24T13:00:46.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/management30-0.jpg">
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>最近读完了段念推荐的<a href="http://item.jd.com/10938548.html" target="_blank" rel="external">《管理 3.0：培养和提升敏捷领导力》</a>，本书是一本结构规整的书，全书将管理理论用六个维度来阐述，然后每个维度下，先讲理论，再讲实践中的故事。</p>
<p>在作者 Jurgen Appelo 的理解下，管理的六个维度是：</p>
<ul>
<li>激励员工：保持员工的活力、创造力和积极性。</li>
<li>授权团队：如何进行自组织。</li>
<li>调合约束：如何保护人力资源以及如何共享资源。</li>
<li>培养能力：如何提高员工技能和提高竞争力。</li>
<li>壮大组织：如何实现组织的成长。</li>
<li>全面改进：如何进行改进。</li>
</ul>
<p>本书对我来说，收获最大的是「壮大组织」（第 12，13 章）部分所介绍的实践。很多想法我自己本身有一些体会，看到书中的介绍就更加清楚了，以下是这部分的一些想法。</p>
<h2 id="u4E13_u4E1A_u4E3B_u4E49"><a href="#u4E13_u4E1A_u4E3B_u4E49" class="headerlink" title="专业主义"></a>专业主义</h2><p>书中提到了专业人才，并且认为专业人才应该是优先被考虑的人才结构。这点我很认同，但是它和部分业界的观点不同。</p>
<p>比如，业界一直在追捧「全栈」工程师，但是其实大部分所谓的「全栈」工程师，是指同时写 Web 前端和后台逻辑。这里的后台逻辑通常也偏业务逻辑一些，不涉及太多的高并发问题。所以，「全栈」工程师更多时候是一种特定业务场景下的需求，在这些特定业务场景下，「全栈」的工程师可以省去沟通前后端接口约定的沟通工作，在出现问题后，也更加便于排查。在 Nodejs 流行后，由于前后端可以统一编程语言，进而可以统一渲染模版，前端工程师更加有动力参与到部分后端的工作中。</p>
<p>但是，「全栈」工程师也仅限于此，涉及到更专业的领域时，组织还是更倾向于使用专业人才。不信的话，你可以问问，很少有人同时做 iOS 和 Android 端的开发，也很少有人同时做客户端和服务器端的「全栈」开发。</p>
<p>但是，在一方面专精，同时对于其它方面又有广泛了解的人员会带来更多的沟通和协作上的效率提升，所以我们都强调培养 T 型人才。T 型人才指在某一方面专长，但是又有着不错的知识面的人。比如 iOS 开发者，如果同时能懂一些产品、交互、服务器端的知识，那么在合作上就会舒服得多。</p>
<h2 id="u6241_u5E73_u5C42_u7EA7_u4E0E_u975E_u6B63_u5F0F_u9886_u5BFC_u529B"><a href="#u6241_u5E73_u5C42_u7EA7_u4E0E_u975E_u6B63_u5F0F_u9886_u5BFC_u529B" class="headerlink" title="扁平层级与非正式领导力"></a>扁平层级与非正式领导力</h2><p>过多的管理层级带来效率低下的沟通和决策过程，所以现在的互联网公司都提倡扁平化的层级。但是在扁平化的层级下同样需要合作和决策，这个时候非正式的领导力就变得更加重要了。</p>
<p>非正式领导力在我们公司并没有被明确提出来，但是它确实反复存在。非正式的领导力在跨部门合作的时候变得异常重要，而这里面也涉及大量的沟通技巧。</p>
<h2 id="u804C_u80FD_u578B_u56E2_u961F_vs__u8DE8_u804C_u80FD_u578B_u56E2_u961F"><a href="#u804C_u80FD_u578B_u56E2_u961F_vs__u8DE8_u804C_u80FD_u578B_u56E2_u961F" class="headerlink" title="职能型团队 vs 跨职能型团队"></a>职能型团队 vs 跨职能型团队</h2><p>这是我又一次见到相关的讨论了，在格鲁夫的《给经理人的第一课》里面也提到了相同的问题。当时，格鲁夫的观点是采用「混合型组织」和「双重汇报」的方式来解决。而本书的作者提出了另外一个思考的角度：沟通的频繁程度。</p>
<p>本书的作者认为，按照复杂系统理论，达成一件事情需要的沟通总量是不变的，所以我们应该让组织的形式更加易于沟通。所以一个人的工作应该归属于职能型团队还是跨职能型团队，就看他和哪边的沟通工作更多。</p>
<p>在这种思考的角度下，作者认为以产品为单位的跨职能型团队是更加符合沟通需求的。因为在开发一款产品时，PM 与开发需要密切地沟通合作，客户端与服务器的开发也需要密切的沟通合作。所以我们应该把他们放在一个团队中，而不应该分开到不同的职能型团队中。</p>
<p>有意思的是，「跨职能型团队」与「决策由组织间自行沟通解决」就构成了敏捷开发中的 Scrum of Scrum 模式。</p>
<img src="/images/management30-1.jpg">
<p>作者在本书中认为（并且他指明具有争议），项目管理、架构级模块、用户界面设计、硬件设计、测试是专业性很强的工作，并且沟通量并没有那么大，可以用职能型专家团队来完成。但是需要服务好项目团队，由项目团队判断职能团队的价值并且建立合适的沟通渠道。</p>
<h2 id="u9002_u5E94"><a href="#u9002_u5E94" class="headerlink" title="适应"></a>适应</h2><p>作者强调企业的组织方式并不是一层不变的，我们可以不变调整适应，如果觉得不合适，就可以继续调整。比如我们发现需要构建出一些架构级的模块时，我们可以临时组建专家团队，当这方面的工作变少时，我们也可以选择将专家团队解散。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>本书还有一些小的翻译问题，例如 P13 把授权团队翻译成赋能团队，P109 把凯文·凯利翻译成科里。</p>
<p>本书的理论部分太过散乱，并且没有重点。实践部分的各章节也不成系统。如果为了节省时间，可以直接看每一章最后的小结，从小结中就可以看出结论非常散。</p>
<p>就像本书最后说的那样，不同的管理理论有不同的模型，本书的六大模型并不一定是正确的，它更多是一种看问题的可选角度。所有模型都有错，但有一部分是有用处的就行了，为方法、框架、原则和实践争得死去活来真的没有必要。</p>
<p>本书对于我的价值，就是再一次思考了组织在壮大过程中的各种问题的解决方案，我们公司的团队正在经历人员增长，跨部门的合作也遇到了很多问题，本书有助于我理解这其中的原因。</p>
<p>最后是我整理出来的知识脉络思维导图，这份图带有我个人的主观色彩，一些我不认同的观点没有整理在里面。</p>
<img src="/images/management30-2.jpg">
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/management30-0.jpg">
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>最近读完了段念推荐的<a ]]>
    </summary>
    
      <category term="books" scheme="http://blog.devtang.com/tags/books/"/>
    
      <category term="books summary" scheme="http://blog.devtang.com/categories/books-summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件开发中的上帝模式与农民模式]]></title>
    <link href="http://blog.devtang.com/2016/07/20/programming-worlds-farmer-and-god/"/>
    <id>http://blog.devtang.com/2016/07/20/programming-worlds-farmer-and-god/</id>
    <published>2016-07-20T12:18:04.000Z</published>
    <updated>2016-09-04T14:29:40.000Z</updated>
    <content type="html"><![CDATA[<img src="/images/god-vs-farmer.jpg">
<p>我在做 iOS 开发的时候，发现自己在写程序的时候，常常处于两种状态的切换，我把这两种状态称为软件开发的上帝模式与农民模式。我先给大家介绍一下这两种模式的特点。</p>
<h2 id="u4E0A_u5E1D_u6A21_u5F0F"><a href="#u4E0A_u5E1D_u6A21_u5F0F" class="headerlink" title="上帝模式"></a>上帝模式</h2><p>处于上帝模式时，我需要构思整个应用的架构设计，如何进行类之间的组织和信息的传递。我有可能会在纸上画一些类图，把关键的几个类之间关系构思清楚。这就类似于建筑师画设计图纸一样。</p>
<p>在这个阶段，我的大脑是努力工作的，我会利用我学到的《设计模式》、《重构》、《代码大全》中的架构知识，先把类的关系组织好。然后我会深入到每一类的实现细节，构思好每个类大概怎么实现，这个过程又会利用了如何命名、DRY 原则、单一职责原则等编程知识。</p>
<p>而这一切的行为，都是在纸上完成的，我甚至会关掉电脑屏幕，因为电脑屏幕前有很多影响注意力的信息（例如 QQ、微信、邮件等）。</p>
<h2 id="u519C_u6C11_u6A21_u5F0F"><a href="#u519C_u6C11_u6A21_u5F0F" class="headerlink" title="农民模式"></a>农民模式</h2><p>当一切构思基本完成，我就会打开 Xcode，开始我的农民模式工作。</p>
<p>在农民模式，我会专心于将我刚刚构思好的内容变成一行行真实的代码。由于已经想得比较清楚，这个过程通常更多是一种体力活，或者好听一点，是一个手艺人的体力活。对于农民模式的我来说，我需要知道 iOS 开发的各种基本知识，以及一些常见的提升效率的工作方式，以便我能够更快地完成编码工作。</p>
<p>在农民模式中，我会注意集中精力，因为虽然实现代码是偏体力活的事情，但是思路如果断掉，接上的话还是会花费不少时间。有一些同事会喜欢戴上耳机，以避免干扰，也是这个道理。</p>
<h2 id="u4E00_u4E2A_u4F8B_u5B50"><a href="#u4E00_u4E2A_u4F8B_u5B50" class="headerlink" title="一个例子"></a>一个例子</h2><p>举一个具体的例子，下图是小猿搜题的发现页面，它明显是用一个 Group Style 的 <code>UITableView</code> 来实现的，每个 Cell 的样式也非常简单：左边有一张 <code>UIImageView</code>，接着是一个 <code>UILabel</code>，然后是靠右侧的 <code>UILabel</code>（可能内容为空）以及最右侧的一张右剪头的 <code>UIImageView</code>。</p>
<img src="/images/ape-discovery.png">
<p>由于这个发现页面可以由服务器来定制，所以我在上帝模式的时候，先构思好我需要实现：</p>
<ul>
<li>一个 View Controller 类（<code>DiscoveryViewController</code>），用于展示整个界面</li>
<li>一个 TableViewCell 类（<code>DiscoveryTableViewCell</code>），用于描述一个条目</li>
<li>一个 ViewModel 类（<code>DiscoveryConfig</code>），用于描述发现页的内容</li>
<li>一个网络请求类（<code>GetDiscoveryApi</code>），用于获得服务器的定制信息</li>
<li>在持久化层（<code>StorageAgent</code>）增加两个方法，用于获取上次缓存的定制内容（<code>getDiscoveryConfig</code>）以及保存最新的定制内容 (<code>saveDiscoveryConfig</code>）</li>
<li>一个负责更新的类（<code>ConfigUpdateAgent</code>），用于处理更新的时机选择（<code>checkUpdate</code>）</li>
</ul>
<p>我还会把每个类大概的成员变量和成员方法名想好。构思完成之后，我脱下上帝的黄袍（别问我上帝为什么要穿黄袍，我也不知道），换上农民干活的麻布衣服，开始搬代码了。我先把这些类都建好，方法名命名好。接着我开始填一个一个的方法名的实现。</p>
<p>每一个类的实现过程都可以看作一个阶段性的成果，这个时候我会稍微休息一下，然后继续搬砖。</p>
<p>最终，我完成了所有代码，然后开始运行。咦，为什么运行效果不对？我赶紧打起精神，开始调试起代码来。这个时候，我一会儿切换成上帝模式，审视自己的架构是否有漏洞。一会儿切换成农民模式，看自己是不是不小心敲错了一些代码细节。</p>
<p>最终，代码被全部编写完成并且运行正常了。</p>
<h2 id="u4E00_u4E9B_u6280_u5DE7"><a href="#u4E00_u4E9B_u6280_u5DE7" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="u4E0A_u5E1D_u6A21_u5F0F_u7684_u6280_u5DE7"><a href="#u4E0A_u5E1D_u6A21_u5F0F_u7684_u6280_u5DE7" class="headerlink" title="上帝模式的技巧"></a>上帝模式的技巧</h3><p>上帝模式中，切忌不应该过于着急动手，把一切的细节都想清楚，看看有没有特殊情况没有考虑到。如果一开始设计得不好，那么真正实现到最后才发现，那么农民模式下写的代码就白白浪费了。</p>
<p>上帝模式的工作是可以脱离电脑来实施的，这意味着我们可以拉上同事，找个白板讨论。我们也可以在上下班的路上思考。</p>
<p>经过讨论的上帝模式的产出会更加靠谱，在我们公司，我们会在 Scrum 的计划会议的后半程，用出牌的方式估计每一个工作的 Story Point，而具体的估计方式，就是以上帝模式将整个工作细化，使得我们大家能够明确出农民模式下的编码工作量到底是多少。</p>
<p>软件开发能力的提高，上帝模式会比农民模式更难，在上帝模式下工作得出色的同学，会进一步成为架构师，成为更复杂架构的设计规划者。</p>
<p>在软件开发书籍中，涉及上帝模式的图书也有很多，例如《设计模式》和《重构》，但是好的架构都是无法脱离实际业务的，所以大多数程序员都无法通过简单地看书就提高自己的上帝模式的能力，更多的提高方式是工作一段时间，有一些实际体会之后再看书，就能够理解书中的道理。</p>
<h3 id="u519C_u6C11_u6A21_u5F0F_u7684_u6280_u5DE7"><a href="#u519C_u6C11_u6A21_u5F0F_u7684_u6280_u5DE7" class="headerlink" title="农民模式的技巧"></a>农民模式的技巧</h3><p>农民模式中，效率是第一要素。所以，保证自己的专注力是非常重要的。在这方面，「番茄工作法」是一个不错的实践方式。</p>
<p>农民模式中，应该尽量采用「宽度优先搜索」的方式来完成任务，而不是「深度优先搜索」的方式。在上面的例子中，我先将各种类的类名和方法名填好，然后再完善细节就是一种「宽度优先搜索」的方式。这种方式下，我们不需要额外的「栈空间」来保存工作的上下文。</p>
<p>为了更容易理解，我来举一个「深度优先搜索」的工作方式，在上面的例子中，我先写界面的 Controller 类，写到一半发现需要 TableViewCell，于是就去写 TableViewCell。TableViewCell 写到一半发现需要先实现 ViewModel，然后就跑去实现 ViewModel，ViewModel 实现完发现需要缓存起来，于是就跑去写缓存逻辑。这种工作方式下，我就需要分别记住：Controller 的进度和 TableViewCell 的进度，以便我之后继续完善它们。这种方式其实就相当于一次「打断」，因为我把 Controller 的编写硬生生拆成了两次，这样就使得我需要更多时间回记上次的思路。</p>
<p>农民模式中，我们应该尽量提升自己的代码输入效率。比如将常用的代码片段保存在 Xcode 的 Snippets 中或者 Dash 中，在组织内规范好统一的命名约定和规则，熟悉 iOS 的各种调试技巧，都可以使自己更快把上帝模式下的蓝图转换成实际代码。</p>
<p>相对于上帝模式，大部分同学都会轻视农民模式下的效率。比如写一会儿代码聊一会儿 QQ。比如由于自己事先积累不够，很多基本的 iOS 开发知识还需要查资料和文档。农民模式下的效率低下，使得一个人看起来工作了很久，却没有什么产出。</p>
<p>在 iOS 领域，我个人的经验表明，我在一整天的农民模式中，最高可以产出 1000 行左右的代码。2012 年猿题库创业初期时，我在 4 个月的紧张工作中，平均每天的代码产出约为 500 行。</p>
<h2 id="u4E00_u4E9B_u95EE_u9898"><a href="#u4E00_u4E9B_u95EE_u9898" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="u63D0_u5347_u4E0A_u5E1D_u6A21_u5F0F_u80FD_u529B"><a href="#u63D0_u5347_u4E0A_u5E1D_u6A21_u5F0F_u80FD_u529B" class="headerlink" title="提升上帝模式能力"></a>提升上帝模式能力</h3><p>很多 iOS 开发新手对于提升自己上帝模式的能力感觉到无从下手，建议这部分同学可以多分析一些优秀的开源软件的架构，同时阅读一些相关的书籍。另外，每一次恶心的重构都是一次难得的经验，说明之前的架构设计不够优雅，结合自身的业务特点，多思考多讨论，慢慢地就会培养出自己对于架构的一些心得了。</p>
<h3 id="u63D0_u5347_u519C_u6C11_u6A21_u5F0F_u6548_u7387"><a href="#u63D0_u5347_u519C_u6C11_u6A21_u5F0F_u6548_u7387" class="headerlink" title="提升农民模式效率"></a>提升农民模式效率</h3><p>很多 iOS 开发新手对于农民模式不够重视。一个程序员大部分时间都应该是处于农民模式的，农民模式决定了我们产出的效率，而很多人只重视工作时间，不重视工作效率，使得自己的产出非常低下。</p>
<p>提升自己的农民模式能力，建议使用「番茄工作法」并且做一些时间记录，平时多学习一些最新的 iOS 开发知识，以便减少自己的知识盲区。专注于自己的精力是否集中，如果觉得太累，就活动一下或者适当休息，不应该强迫自己 Coding。</p>
<h3 id="u8B66_u60D5_u6DF7_u642D_u6A21_u5F0F"><a href="#u8B66_u60D5_u6DF7_u642D_u6A21_u5F0F" class="headerlink" title="警惕混搭模式"></a>警惕混搭模式</h3><p>混搭模式，类似于练功人士的「走火入魔」，专指那些在上帝模式没有想清楚，就马上切入农民模式写代码，写到一半代码又切到上帝模式思考。边写边想的混搭模式使得自己想的时候不够清晰，写的时候又不够专注，两边都不讨好。通常刚刚入行的人都处于这种混搭的模式，不但写出来的代码容易有逻辑错误，而且速度很慢。</p>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>上帝模式与农民模式这个叫法是我自己发明出来的，你喜欢这个世界观设定吗？</p>
<p>我们在程序的世界里，一会儿是高高在上的上帝，一会儿又是埋头干苦活的农民，想想也挺奇妙的。</p>
<p>愿大家在这个世界中玩得开心！</p>
<p>如果你感兴趣，这儿还有我的另一个世界观设定：<a href="/2016/09/04/open-your-brain/">《打开你的脑洞》</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<img src="/images/god-vs-farmer.jpg">
<p>我在做 iOS 开发的时候，发现自己在写程序的时候，常常处于两种状态的切换，我把这两种状态称为软件开发的上帝模式与农民模式。我先给大家介绍一下这两种模式的特点。</p>
<h2 id="u4E0A_]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[成长为 iOS 大 V 的秘密]]></title>
    <link href="http://blog.devtang.com/2016/07/20/from-newbie-to-master/"/>
    <id>http://blog.devtang.com/2016/07/20/from-newbie-to-master/</id>
    <published>2016-07-20T12:17:53.000Z</published>
    <updated>2016-07-20T12:17:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>毫不谦虚地说，我是国内 iOS 开发的大 V。我从 2011 年底开始自学 iOS 开发，经过 3 年时间，到 2014 年底，我不但写作了上百篇 iOS 相关的原创博客文章，完成《iOS 开发进阶》，同时还成功运营了「iOS 开发」这个国内最多 iOS 开发者订阅的微信公众号，另外我的微博（@唐巧_boy）粉丝超过 4 万。我是如何做到的呢？</p>
<p>在武侠小说里面，武林高手通常生来就有慧根，是个学武奇才，就像周星驰《功夫》里面的星仔。另外，他们还通常会得到世外高人的指点，要么获得别人毕生修炼的真气（虚竹），要么获得绝世武功的秘笈（段誉）。</p>
<p>而我其实在这些方面都很弱。我在计算机编程方面并算不上聪明，我在北京师范大学读计算机专业，这是一个全国综合实力排在 100 名开外的院系，离清华北大差得不是一个级别。而我的语文高考成绩，刚刚及格。我的英语成绩也很一般。</p>
<p>更不凑巧的是，我当年学 iOS 的时候，国内资料很少，而且公司里面没人有时间指导我，我只能自学。很难想像，我这么差的背景的人，能够成为 iOS 大 V，能够写文章，甚至还出书。</p>
<p>那么，我成为 iOS 大 V 的秘密是什么呢？请听我慢慢道来。</p>
<h2 id="u5927_V__3D__u5927_u725B__uFF1F"><a href="#u5927_V__3D__u5927_u725B__uFF1F" class="headerlink" title="大 V = 大牛 ？"></a>大 V = 大牛 ？</h2><p>首先我想讨论一个问题：「大 V = 大牛」吗？其实很多时候，这两者并不能直接划等号。</p>
<p>我见过很多大牛，他们水平很高，但是他们或者不善于表达，或者不善于写作，或者表达和写作都没问题，但是他们并不喜欢在网上高谈阔论，更喜欢把时间花在研究技术问题上。这些大牛，就像《天龙八部》里面的扫地僧一样，不曾被外界知晓，但是技术实力一流。</p>
<p>我也见过一些大 V，技术实力一般，但是喜欢分享自己的心得，喜欢翻译国外的博文。他们有一些人甚至不善于写作，写文章喜欢大段大段地贴代码。但是，随着他在这方面不断地锻炼，他们慢慢地写作得越来越好，讲解技术越来越通俗易懂。因为频繁地交流，他们的技术实习也在不停地进步。虽然这些大 V 的真实水平可能比不过一些从不分享的大牛，但是他们的能力至少是达标的。</p>
<p>所以，我对这个问题的答案是：大 V 不等于 大牛。但是，要成为一个大 V，至少应该具备以下条件：</p>
<ul>
<li>能力是达标的，不应该有明显的能力问题。</li>
<li>喜欢交流，认识很多业界同行。</li>
<li>喜欢表达，通过写作和线下分享来传播知识。</li>
</ul>
<p>所以，我们不应该盲目崇拜大 V，他们只是喜欢分享而已。</p>
<p>那我算一个 iOS 的大牛吗？我不知道。有一些人认可我，也有一些人觉得我很一般。但是我的原创文章、我的书、我开源的代码、我做的每次分享都公开在网上。我仅仅用三年时间在 iOS 领域做到这些也是不容易的，所以希望大家继续看下去，看我是如何做到的。</p>
<h2 id="u5947_u6750_+__u79D8_u7B08_uFF1F"><a href="#u5947_u6750_+__u79D8_u7B08_uFF1F" class="headerlink" title="奇材 + 秘笈？"></a>奇材 + 秘笈？</h2><img src="/images/ios-secret-1.jpg">
<p>在武侠小说里面，武林高手通常生来就有慧根，是个学武奇才，就像周星驰《功夫》里面的星仔。另外，他们还通常会得到世外高人的指点，要么像虚竹那样，获得别人毕生修炼的真气；要么像段誉那样，获得绝世武功的秘笈。</p>
<h3 id="u6211_u662F_u4E00_u4E2A_u5947_u6750_u5417_uFF1F"><a href="#u6211_u662F_u4E00_u4E2A_u5947_u6750_u5417_uFF1F" class="headerlink" title="我是一个奇材吗？"></a>我是一个奇材吗？</h3><p>我是一个奇材吗？显然不是。</p>
<p>我从小就喜欢计算机，从高中就开始接触计算机编程，我还记得那个时候学的是 PASCAL 语言，从那个时候起，我就展现出在计算机编程方面的愚钝。我还记得我和同班的小伙伴一起学习递归枚举，他大概只花了三天就看懂了相关的代码，而我花了整整一个月。</p>
<p>我的高考成绩其实也很一般，不过我运气比较好，当年全国试行自主招生，我靠着自主招生进入了北京师范大学，在北京师范大学读计算机专业。这是一个全国综合实力排在 100 名开外的院系，离清华北大差得不是一个级别。我靠着高中时积累的一点点编程知识混进了学校的 ACM 校队，之后一直比赛成绩一般，直到研一的时候才免强获得了亚洲区的区域赛金奖。</p>
<p>我的实习经历也非常不顺。我从大四就开始找实习，一直被拒，到研究生阶段还是找不到实习。最终还是靠刚刚说的区域赛金奖，获得了来自赞助商 IBM 的一次实习机会。</p>
<p>大 V 需要擅长写作，而我的高考语文成绩，92 分（满分 150），刚刚及格。我的英语成绩也很一般。</p>
<p>所以，我就是一个天资普通得不能再普通的一个人。</p>
<h3 id="u6211_u6709_u9AD8_u4EBA_u6307_u70B9_u5417_uFF1F"><a href="#u6211_u6709_u9AD8_u4EBA_u6307_u70B9_u5417_uFF1F" class="headerlink" title="我有高人指点吗？"></a>我有高人指点吗？</h3><p>那我有高人指点吗？很可惜，也没有。</p>
<p>我不但没有高人指点，而且我学习 iOS 开发的过程极其曲折。</p>
<h4 id="u6CA1_u6709_u8D44_u6599"><a href="#u6CA1_u6709_u8D44_u6599" class="headerlink" title="没有资料"></a>没有资料</h4><p>我是在 2011 年底开始学习 iOS 开发的。当时我厌倦了服务器端的开发，感觉移动互联网很火，于是想做 iOS 开发。但是，当时移动开发刚刚兴起，国内外甚至都没有一本像样的 iOS 图书。当时除了一本入门的基础书，教你使用各种 UI 控件外，就只剩下一本满是代码的书，教你各种小技巧（比如如何读文件，如果发个网络请求之类）。</p>
<h4 id="u6CA1_u6709_u4EBA_u5E26"><a href="#u6CA1_u6709_u4EBA_u5E26" class="headerlink" title="没有人带"></a>没有人带</h4><p>我当时在有道云笔记组，负责 iOS 开发的同学并不太擅长带人，所以我很遗憾基本上只能自己学习和研究 iOS 开发知识。</p>
<h4 id="u5B66_u4E60_u65F6_u95F4_u77ED"><a href="#u5B66_u4E60_u65F6_u95F4_u77ED" class="headerlink" title="学习时间短"></a>学习时间短</h4><p>我以为公司会给我一些时间让我学习 iOS 开发，但是真实的情况是，我只有两周的时间学习！两周之后，我就需要帮忙修复线上的 iOS 代码，以及参与功能开发了。</p>
<p>我不知道大家是花多久学完 iOS 开发的。有一些同学报 iOS 培训班，在有老师讲的情况下，一学就学三个月。而我，只有两周的时间。</p>
<h4 id="u80CC_u666F_u77E5_u8BC6_u4E3A_u96F6"><a href="#u80CC_u666F_u77E5_u8BC6_u4E3A_u96F6" class="headerlink" title="背景知识为零"></a>背景知识为零</h4><p>我在学习 iOS 开发前，对客户端开发一无所知，我当时没有用过 Mac 机，没有 iPhone。一切东西对我来说都还非常神秘。</p>
<h4 id="u6CA1_u6709_u65F6_u95F4_u63D0_u9AD8"><a href="#u6CA1_u6709_u65F6_u95F4_u63D0_u9AD8" class="headerlink" title="没有时间提高"></a>没有时间提高</h4><p>我从 2011 年底开始学 iOS 开发，到 2012 年 5 月份就离职创业了。那个时候因为创业刚开始，我们进入了长期的 6 天，每天 11 小时的高强度工作方式。我想提高自己的 iOS 水平，但是每天工作下来都很晚了，而且写了一整天代码精疲力尽，实在没有时间提高。</p>
<h3 id="u6211_u7684_u6210_u5C31"><a href="#u6211_u7684_u6210_u5C31" class="headerlink" title="我的成就"></a>我的成就</h3><p>但是，在自身条件一般，环境恶劣的情况下，我还是做到了自我的快速成长，并且收获了很多成绩：</p>
<ul>
<li>我从开始学习 iOS 开发半年后，就开始独立负责 iOS 端的开发工作。</li>
<li>我从 2013 年 1 月创建「iOS 开发」微信公众帐号，然后每周坚持更新，现在有超过 3 万 5 千的订阅量。</li>
<li>我从 2013 年底开始撰写《iOS 开发进阶》，2014 年底完成。另外我还写了一年多 「iOS 开发周报」。</li>
<li>我将公司的网络库，Key-Value 存储库开源，GitHub 上 Star 数上千。</li>
<li>我坚持写 iOS 技术博客，现在完成了超过 100 篇原创文章，很多发表在 InfoQ 和 《程序员》杂志上。</li>
</ul>
<h2 id="u6211_u662F_u5982_u4F55_u505A_u5230_u7684"><a href="#u6211_u662F_u5982_u4F55_u505A_u5230_u7684" class="headerlink" title="我是如何做到的"></a>我是如何做到的</h2><p>那我是如何做到的呢？</p>
<h3 id="u89E3_u51B3_u5165_u95E8_u7684_u95EE_u9898"><a href="#u89E3_u51B3_u5165_u95E8_u7684_u95EE_u9898" class="headerlink" title="解决入门的问题"></a>解决入门的问题</h3><p>学习 iOS 开发，没有相关硬件是不行的。但是苹果的硬件都很贵，很多人舍不得买，装黑苹果来解决，这种行为我简单尝试了一下就放弃了，因为黑苹果有着太多的兼容和性能问题，在这上面浪费时间非常不值得。于是，我还是自己掏钱买了 Mac 机和 iPad，为了省钱，我买的第一台 Macbook Pro 是从同学手中买的二手货，我买 iPad 而不是 iPhone，其实也是为了省钱，因为 iPad 不但相对来说更便宜，而且可以同时做 iPhone 和 iPad 的开发用。</p>
<p>国内没有学习资料怎么办呢？只有硬着头皮看国外的资料呗。其实当时国外的资料也不多。我是一个视觉型的学习者，所以我看的是斯坦福的iOS开发视频课程。前几节课看的是网易云课堂上的带中文字幕的版本，但是字幕只到第10课，后面的课程我就直接看的无字幕的原始视频。</p>
<p>两周的时间虽然比起外面的培训机构短很多。但是安排得好的话，每天还是可以学习很多。我大概一周就看完了视频课程，然后就是不停地写程序练习。虽然没有人带我，但是当时有道公司内部的所有 iOS 工程代码我其实也是可以用来学习的。所以我仔细阅读了有道词典和有道云笔记的代码。</p>
<p>于是，两周之后，我就开始参与工程Bug的修复工作了。差不多一个月左右，我就开始负责一部分开发工作了。</p>
<h3 id="u89E3_u51B3_u4EA4_u6D41_u8BA8_u8BBA_u7684_u95EE_u9898"><a href="#u89E3_u51B3_u4EA4_u6D41_u8BA8_u8BBA_u7684_u95EE_u9898" class="headerlink" title="解决交流讨论的问题"></a>解决交流讨论的问题</h3><p>虽然我很快完成了iOS的入门学习，但是感觉交流很少，很多问题没有人讨论，这对于自己提高开发能力是一个很大的障碍。于是，我开始组织各种分享交流会。</p>
<p>刚开始我尝试在公司内部做这种交流工作，发现推进得非常困难，主要是喜欢分享的人还是比较少。有道的技术牛人其实是不少的，但是就像我刚刚说的那样，大牛不等于大V，大牛也不代表着乐于并且擅长分享。所以，经过了快两个月的推进，技术交流会还是非常少。大家都会说没有时间准备，而我又没有任何权力在强行要求同事做分享。</p>
<p>我苦恼了很久，最终到创业的时候，才发现我之前眼光太浅，世界那么大，我为什么要把交流的圈子定在公司内部呢？在创业的时候，我开始从全国范围内主动寻找和结识乐于分享的 iOS 开发者。我会从微博，博客，技术分享会，前同事等各种渠道去寻找这样的朋友。其实，对于乐于分享的人来说，你要做的事情就只是把他们聚到一起就行了，他们自己就会开始不停地交流、讨论、分享。</p>
<h3 id="u89E3_u51B3_u63D0_u9AD8_u7684_u95EE_u9898"><a href="#u89E3_u51B3_u63D0_u9AD8_u7684_u95EE_u9898" class="headerlink" title="解决提高的问题"></a>解决提高的问题</h3><p>大部分 iOS 开发者在入门一段时间后，就会苦于不知道如何提高。其实，提高的方式有很多，只要舍得花时间。我在提升个人技能方面，主要做了这些事情：</p>
<ul>
<li>看 WWDC 的视频。因为由苹果官方提供，并且每年更新，所以 WWDC 是学习 iOS 开发新知识最好的渠道。我利用我每天上下班坐地铁的时间来学习，遇到一些关键的知识在地铁上不好做笔记，我会直接用截屏的方式把这些知识截下来，然后晚上在家里再把内容整理下来。下图是我在 Evernote 中记录的 WWDC 笔记，大家可以看到，一共有 70 多篇。</li>
</ul>
<img src="/images/wwdc-notes.jpg">
<ul>
<li><p>看 iOS 的博客。我用 RSS 聚合阅读器定阅了大量国外 iOS 的博客，然后利用碎片时间阅读。我的 Evernote 上收藏了上百篇的精选文章。我的碎片时间大多是上厕所和睡觉前。那个时候智能手机刚刚兴起，还没有微信，我感觉现在很难做到在手机上安静地做阅读了。</p>
</li>
<li><p>写作。对于我个人来说，我会坚持用写作的方式来学习。因为我觉得写作是知识理解的最高层次。美国教育心理学家 Bloom 将知识认知历程维度分为 6 个层次，分别为：记忆、理解、应用、分析、评鉴、创造。如下图所示，层次越高，表示对知识的掌握程度越深。我每次觉得我理解了一个知识后，就会用写作的方式把它写下来，通常情况下，在写作的过程中我都会发现自己的一些认知不足，从而通过二次学习来完善。</p>
</li>
</ul>
<img src="/images/why-write-1.png">
<h2 id="u6211_u7684_u5FC3_u5F97"><a href="#u6211_u7684_u5FC3_u5F97" class="headerlink" title="我的心得"></a>我的心得</h2><p>在这个过程中，我也发现了一些以前认识上的误区。</p>
<h3 id="u65F6_u95F4_u662F_u6700_u5927_u7684_u501F_u53E3"><a href="#u65F6_u95F4_u662F_u6700_u5927_u7684_u501F_u53E3" class="headerlink" title="时间是最大的借口"></a>时间是最大的借口</h3><p>有一些朋友评价我：「迷之高产」，他们不理解我是如何有那么多时间搞定各种事情。</p>
<p>在我看来，当你做不好某一件事情时，时间通常是最大的借口。</p>
<h4 id="u65F6_u95F4_u662F_u53EF_u4EE5_u5BFB_u627E_u7684"><a href="#u65F6_u95F4_u662F_u53EF_u4EE5_u5BFB_u627E_u7684" class="headerlink" title="时间是可以寻找的"></a>时间是可以寻找的</h4><p>我学习 iOS 开发半年后，我就从网易离职参与创业了。当时我们需要工作 6 天，每天 11 个小时。但是，这仍然没有影响我学习、交流、甚至写作。其实你仔细记录自己的时间之后，就会发现有很多时间可以利用。</p>
<p>比如我在那段紧张的创业期间，就利用每天上下班的时间，在地铁上看 WWDC 视频。</p>
<p>我自认为最夸张的事情是利用陪老婆逛街的时候写博客文章。当时我老婆和岳母在商场里面逛，我就在手机上写文章。其实试过之后发现，在手机上写文章的速度也算不上慢。</p>
<p>现在，我有了小孩，周末常常要陪伴她。我就会特别珍惜晚上 8 点后她睡着后那段时间，我可以利用那段时间做一些学习和写作的事情。</p>
<h4 id="u65F6_u95F4_u662F_u53EF_u4EE5_u6324_u7684"><a href="#u65F6_u95F4_u662F_u53EF_u4EE5_u6324_u7684" class="headerlink" title="时间是可以挤的"></a>时间是可以挤的</h4><p>如果我们提高工作的效率，那么做同样的事情，你就会比别人花费更少的时间。这样我们就可以挤出时间做别的事情。</p>
<p>程序员这个工作特点是需要集中精力，所以应该尽量避免被别人打断。推荐大家使用番茄工作法，让自己能够在短时间内集中精力做一件事情。久而久之，你就可以快速进入编程状态。</p>
<p>另外，写代码之前，先在纸上把逻辑写清楚，这样会使得自己 Coding 的过程非常顺利。有一些人喜欢边写边想，这样如果遇上一些没想清楚的情况，就可能白写一部分代码。在纸上把逻辑先写清楚后，Coding 的节奏会非常轻松，因为你的脑海里已经有整个架构的蓝图了，即使中间暂停休息一下，也不会有很大的影响。</p>
<h4 id="u5E73_u8861_u597D_u65F6_u95F4_u548C_u4EE3_u7801_u8D28_u91CF"><a href="#u5E73_u8861_u597D_u65F6_u95F4_u548C_u4EE3_u7801_u8D28_u91CF" class="headerlink" title="平衡好时间和代码质量"></a>平衡好时间和代码质量</h4><p>有一些人写代码，完全是堆功能，不考虑可维护性，你如果批评他，他就会义正言辞地说：时间不够！</p>
<p>另外有一些人，追求代码质量，宁愿项目长时间延期，也不愿意写出看起来脏的代码。遇到需求变更，总是要进行大幅度的重构，以保证新的架构是最优雅的。</p>
<p>我有很长一段时间都是后者，但是我现在觉得，我们不应该走极端，我们应该平衡好时间花费和代码质量。</p>
<p>从商业上来说，按时交付产品比什么都重要，一家创业公司，如果不能按时交付产品，可能它就会面临资金不够的问题而倒闭，也可能被竞争对手抢先推出类似产品，在竞争上失去时间上的优势。</p>
<p>所以一个好的程序员，更应该有「大局观」，在保证代码质量的同时，也能明白，良好的代码质量其实是为了长期的可持续地按时响应需求变更、人员变更，以达到「按时交付产品」。</p>
<h3 id="u8FD0_u7528_u5FC3_u667A"><a href="#u8FD0_u7528_u5FC3_u667A" class="headerlink" title="运用心智"></a>运用心智</h3><h4 id="u4EC0_u4E48_u662F_u5FC3_u667A"><a href="#u4EC0_u4E48_u662F_u5FC3_u667A" class="headerlink" title="什么是心智"></a>什么是心智</h4><p>关于什么是心智，我来讲一个故事吧。</p>
<p>我老婆是学幼儿教育的，她给我讲过一个故事，幼儿教育学家为了研究小孩的自控能力，会做一个叫做 <a href="http://baike.baidu.com/link?url=8EKV-tjzMsKQFVnSnr1Ar3VWf8iCbKTdvH1AZHJXzWcBPJO38hQZd12cKIbrjgQIgjl-tmqPhfR4Z8oFPjcpXK" target="_blank" rel="external">延迟满足</a> 的实验。这个实验（<a href="https://www.youtube.com/watch?v=Yo4WF3cSd9Q" target="_blank" rel="external">相关视频</a>）是这样的：</p>
<blockquote>
<p>在一个屋子里面，让小孩坐在一个书桌前，然后给小孩一个糖果，告诉他：「我 15 分钟后回来，如果你在我回来之前都不吃这个糖果，等我回来后就再奖励你一个糖果」。</p>
<p>通常情况下，很多小孩都无法抵抗糖果的诱惑而很快将它吃掉。而研究发现，那些坚持到最后的小孩，自控能力更强，在随后的跟踪研究发现，这些小孩能够在学校取得更好的学习成绩。</p>
</blockquote>
<p>研究人员对这些表现出优秀控制力的小孩很好奇，想进一步分析出他们有什么特点。研究人员甚至用功能磁共振成像仪为他们的脑部进行扫描，希望通过对比扫描图，找出大脑对 “延迟满足” 能力起作用的特定区域。此外，研究人员还进行了不同的基因测试，以研究是否存在控制 “延迟满足” 能力的遗传因素。</p>
<p>最后，研究人员发现，这些小孩都会非常简单的一招：转移注意力。具体来说，他们会在特别想吃糖果的时候，选择做别的事情来让自己大脑暂时不那么关注糖果。比如他们可能会唱歌，在桌子上写字，将头转向窗外。</p>
<p>这个故事就是关于心智最好的解释，小朋友教会我们不要抵抗人性，要利用人性。他们知道自己喜欢吃糖果，但是他并不是强制让自己不喜欢吃糖果了，而是用别的办法来达到目的。</p>
<p>如果你合理利用人智，那么就会收获巨大的威力。</p>
<h4 id="u57F9_u517B_u4E60_u60EF"><a href="#u57F9_u517B_u4E60_u60EF" class="headerlink" title="培养习惯"></a>培养习惯</h4><p>培养习惯应该是最简单的心智利用手段。人们对做一件事情会有惰性，但是一旦培养成习惯之后，不做这件事情反倒不习惯了。所以那些值得做的事情，大家都应该在开始的一段时间内，强行让自己在固定时间点做这些事情，久而久之，就会形成习惯，让它成为你受益终身的习惯。</p>
<p>不止是个人，组织的协作也应该培养习惯。我们在用 Scrum 用项目推进时，会固定每天和每周的开会时间，以及产品的上线时间，这些都会让组织减小对于协作的管理成本。比如每周一晚上需要完成 App 的测试，大家就会自发地紧张起来，将遗留的 Bug 一一修复。</p>
<h4 id="u8BBE_u7ACB_u76EE_u6807"><a href="#u8BBE_u7ACB_u76EE_u6807" class="headerlink" title="设立目标"></a>设立目标</h4><p>很多事情，当我们没有目标的时候，执行的动力就会差很多。所以，我在学习 iOS 开发的时候，会不断地给自己设立一些目标，通过不断强化这个目标，这样使得我在学习的时候意愿变得更强了。当目标达成之后，成就感和自信心就由此产生，从而激励我们更加努力，由此产生出良性的循环。</p>
<p>具体来说，我在学习初期不断要求自己将学习内容整理成博客文章，我要求自己每个月至少写一篇。我的第一篇 iOS 文章是从 2011 年 8 月开始写的，那个时候我才刚刚开始学习 iOS，当时看苹果的内存管理的官方文档，有一些心得，就写了下来。然后关于写博客这件事情我就一直没有间断，一直写到现在。</p>
<p>在文章积累到一定程度之后，我给自己设立的第二个目标是完成一本书。我希望借此机会，将自己没有系统整理的知识再梳理一次。这个目标对我其实挑战很大，最终我从中学会了将图书的撰写拆分成很多小的目标，然后一步一步达成。</p>
<p>把大目标拆分成小的阶段性目标这一点很重要，它使得整体的时间安排是适当的，不会刚开始过紧或过松。另一方面，很一次完成小任务的满足感，可以适当让我们的大脑产生喜悦，最终使得任务更容易被搞定。</p>
<h4 id="u5BFB_u627E_u6210_u5C31_u611F"><a href="#u5BFB_u627E_u6210_u5C31_u611F" class="headerlink" title="寻找成就感"></a>寻找成就感</h4><p>人是需要激励的，《异类》一书中讲到，那些刚开始只有一点点天赋的人，因为不断被人夸奖，从而使得他们更加强化自己擅长的事情，从而获得成功。</p>
<p>所以，我们应该学会给自己做的事情寻找成就感。除了通过完成目标来获得成就感以外，我们还可以有更多的成就感来源。对于我来说：</p>
<ul>
<li>我会从写文章分享知识这个过程中寻找成就感，因为这帮助了其他人学习 iOS 知识。</li>
<li>我会从给 InfoQ 和《程序员》杂志的投稿中寻找成就感，因为它让我感觉到了知识被认可。</li>
<li>我还会从粉丝的转发和评论中寻找成就感，它让我小小的内心充满了被认可的感觉。</li>
<li>我还会从文章的打赏中寻找成就感，毕竟金钱打赏是对文章质量最直接的肯定。</li>
</ul>
<p>这些成就感，驱使着我，让我更加努力学习，停不下来。</p>
<h4 id="u9002_u5EA6_u575A_u6301"><a href="#u9002_u5EA6_u575A_u6301" class="headerlink" title="适度坚持"></a>适度坚持</h4><p>总会有一些事情，你不那么容易找到目标和成就感。</p>
<p>我在 2013 年开始做「iOS 开发」微信公众号的时候，就有这种感觉。每周都要坚持推送消息很辛苦，而且刚开始的时候，粉丝很少，没有人看。我有无数个理由停止做这件事情。但是，我有一个习惯，就是决定做一件事情之后，先做一段时间再说。</p>
<p>当时我给自己设立的目标是，先做半年再说。于是，我就继续更新。机会总是给有准备的人，做着做着，我发现关注数慢慢上升了，我就给自己打气说，慢慢会好起来，于是又继续坚持。终于坚持到 2015 年，我的关注数超过 2 万，也开始有了广告收入。</p>
<p>还是《异类》那本书里面提到了 10000 小时定理，这个观点其实给我很大的鼓舞，它让我们所有人意识到，不论你是否聪明，你都可以用简单地坚持，来成为某个领域的专家。我之前做 iOS 开发时就想，我平时上班一天 8 小时，一年 260 天工作，这样一年是 2000 小时，我大概需要 5 年才能成为 iOS 专家。但是如果我每天工作 10 小时，每周末多拿一天学习 iOS 开发知识，那么我一年可以花在 iOS 上的时间是 10（小时） * 310（天）= 3100 小时，这样我只需要 3 年多一点，就可以成为 iOS 专家了。</p>
<p>我不但是这么 YY 的，我也是这么做的，是的，我就是希望我用三年的时间，达到别人五年的工作经验。事实上，我确实做到了，我相信所有其他人也都可以做到。</p>
<h2 id="u8425_u9500"><a href="#u8425_u9500" class="headerlink" title="营销"></a>营销</h2><p>虽然和个人成长没关系，但是成为大 V 确实需要一些个人的营销。我在这方面其实做得不多，细数下来，我做过下面这些营销的事情：</p>
<ul>
<li>「iOS 开发」公众号坚持三个月后，请冯大辉帮忙推荐过一次，请池建强推荐过一次。</li>
<li>我的微博坚持只发 iOS 开发的消息，刚开始的时候没有粉丝，我请池建强帮我转过几次文章。</li>
<li>图书出版后，和出版社合作搞过几次转发送书活动。</li>
<li>和荔枝软件搞过几次 Mac 正版软件特惠活动。</li>
</ul>
<p>我在营销上其实做得不算好，我在成为大 V 这条路上真正的成功秘诀，还是不断坚持。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总结一下本文的观点：</p>
<ul>
<li>大 V 不等于 大牛，不要盲目崇拜。</li>
<li>时间是最大的借口。</li>
<li>合理运用心智（培养习惯、设立目标、寻找成就感）。</li>
<li>适度坚持。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>毫不谦虚地说，我是国内 iOS 开发的大 V。我从 2011 年底开始自学 iOS 开发，经过 3 年时]]>
    </summary>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在创业四周年]]></title>
    <link href="http://blog.devtang.com/2016/07/16/startup-4th-year-summary/"/>
    <id>http://blog.devtang.com/2016/07/16/startup-4th-year-summary/</id>
    <published>2016-07-16T04:07:05.000Z</published>
    <updated>2016-07-16T04:46:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><p>一转眼，创业四周年了。我从来没有想到过，我的职业生涯中，待得最久的是猿题库这家创业公司。2016 年 5 月 31 日，我们宣布了获得腾讯的 <a href="http://tech.qq.com/a/20160531/011514.htm" target="_blank" rel="external">4000 万美元投资</a>，这是腾讯在 K12 在线教育领域最大的一笔战略投资。拿 BAT 的钱更像是一种站队行为，腾讯拥有 QQ 和微信两大社交平台，如果要选的话，腾讯理应是最好的选择。趁着拿到融资的机会，我们顺便把公司名从「猿题库」改成了「猿辅导」，我们希望从「猿辅导」中，找到合适的商业化道路。</p>
<img src="/images/yuanfudao-company.jpg">
<p>说说我个人吧，和两年前的创业总结 <a href="/2014/10/01/startup-2nd-year-summary/">《写在创业两周年》</a> 相比，我最大的变化是从一名纯 iOS 开发，转变为一个项目负责人。</p>
<h2 id="u65F6_u95F4_u6D41_u6C34"><a href="#u65F6_u95F4_u6D41_u6C34" class="headerlink" title="时间流水"></a>时间流水</h2><p>2014 年 7 月小猿搜题立项，我开始负责这个项目。刚开始我一边负责 iOS 的开发工作，一边参与产品稿和 UI 稿的讨论。当时的我以非技术工作还很陌生，基本上不太敢提意见，不过产品稿都有郭常圳和产品委员会把关，因此并不会带来什么问题。</p>
<p>2014 年 9 月底小猿搜题第一版上线，我们当时评测显示和竞争对手算法差别不大，不过产品层面上，还有许多需要打磨的地方。</p>
<p>2015 年初，我们认为产品打磨得差不多了，于是开始了大规模的运营推广。我们很快在用户量和搜索量上，将某个竞争对手甩开了。</p>
<p>我在负责小猿搜题项目时，首先需要解决的是将 iOS 开发的事情交出去，如果我一直在 iOS 开发具体工作上耗费精力，我就无法关注别的事情了。但是招聘从来都不是一件容易的事情，相比 iOS 开发，我又觉得产品和项目管理的事情更重要，所以在 2014 年的最后两个月，有一些 iOS 端的开发工作被我延后了。</p>
<p>2015 年 1 月，我招到了一个 iOS 开发新手，于是开始带她，差不多带了 3 个月之后，我发现她基本可以独立工作了，所以就只做 code review 的事情。后来 6 月份的时候，我又招过来一个 iOS 开发新手，我指导他做了一些安全方面的工作之后，他们开始相互 review 代码，我参与过几次之后，我发现他们做得很好，所以就不再参与了。</p>
<p>安卓方面，刚开始从猿题库项目组调来一个应届生新人，同时猿题库的安卓负责人参与我们的 review 工作。也是等到这个新人熟悉工作后，他就开始独立开发了，之后补充了一个社招的安卓开发。</p>
<p>小猿搜题在 2015 上半年，相继补充了测试工程师，服务器开发，web 前端开发，产品实习生。到 2015 下半年，我们的团队基本成型了。</p>
<p>2016 年，我们的团队继续扩张，我有些管理不过来。我尝试将一些事情授权给别人，比如培养技术负责人和产品负责人。我们也明确了 iOS 和 Android 端的负责人，以便于更有效地沟通。</p>
<h2 id="u4E2A_u4EBA_u6210_u957F"><a href="#u4E2A_u4EBA_u6210_u957F" class="headerlink" title="个人成长"></a>个人成长</h2><p>对于我来说，我开始像<a href="/2016/02/16/the-leadership-pipeline-summary/">《领导梯队》</a>那本书讲的那样，一开始经历了从管理自我到管理他人的阶段，而现在又开始经历从管理他人到管理经理人员的阶段。</p>
<h3 id="u4ECE_u7BA1_u7406_u81EA_u6211_u5230_u7BA1_u7406_u4ED6_u4EBA"><a href="#u4ECE_u7BA1_u7406_u81EA_u6211_u5230_u7BA1_u7406_u4ED6_u4EBA" class="headerlink" title="从管理自我到管理他人"></a>从管理自我到管理他人</h3><p>从管理自我到管理他人，我学习到的技能点包括：</p>
<p>授权。在从管理自我到管理他人的阶段中，我学会了尽量放弃自己亲力亲为，特别是开发工作。因为开发工作需要长时间集中注意力，而我本身的工作性质导致沟通工作较多，容易被打断。足够的授权才能为自己争取到额外的时间，在授权的同时加以一些监督和检查，就又可以即保证新人得到锻炼，又保证这些工作的质量。</p>
<p>项目进展。管理他人另一个需要注意的就是关注于项目的进展，通常情况下都会有各种各样的问题需要介入讨论，保证进度。</p>
<p>沟通。管理他人中，沟通是一个很重要的环节，新人刚来的一个月是我特别花精力沟通的阶段。沟通的技能包括一对一沟通、绩效沟通、以及平常对于错误行为的及时纠正。其实保持友谊也很重要，不过人多了可能也确实比较难以做到。</p>
<p>流程。关注于规则是否有利于大家工作，是否需要改进。</p>
<h3 id="u4ECE_u7BA1_u7406_u4ED6_u4EBA_u5230_u7BA1_u7406_u7ECF_u7406_u4EBA_u5458"><a href="#u4ECE_u7BA1_u7406_u4ED6_u4EBA_u5230_u7BA1_u7406_u7ECF_u7406_u4EBA_u5458" class="headerlink" title="从管理他人到管理经理人员"></a>从管理他人到管理经理人员</h3><p>从管理他人到管理经理人员阶段，我正在学习。</p>
<p>时间点。我发现在这一阶段，我无法细致到项目进展的每一方面，所以我对于项目进展的推动更多地依赖于别人了。而我只能强调时间点。具体的细节问题推进，我更多地依赖于别人。</p>
<p>沟通。由于人员变多，我只能和重要的负责人进行沟通了，不过和他们的沟通频率应该变得比以前更高，我通过和他们沟通，来获得更细致的项目进展问题和流程上的问题。</p>
<p>其它沟通。沟通不止是向下的，也包括向上的沟通和横向的跨组沟通。这部分工作也开始越来越占用时间了。</p>
<p>产品。我更多地思考产品方向，看一些产品数据或问题。</p>
<p>培训。我开始做一些培训，给相关负责人或者是新员工。给负责人的培训更多是通过聊天讨论的方式，因为这样一对一的讨论是更容易达成一致的。给新员工的培训更多是一对多分享的方式。</p>
<h3 id="u601D_u8003"><a href="#u601D_u8003" class="headerlink" title="思考"></a>思考</h3><p>看起来管理他人的职位会涉及具体的业务细节的讨论和推进，属于在「一线」的管理人员，这些管理人员通常也具备不错的专业能力。</p>
<p>管理经理人员的职位会相对脱离「一线」，他的工作会有更多沟通的事情，和老大的向上沟通，和运营，研究，市场，HR 部门以及兄弟产品的横向沟通，和负责人的沟通，这些事情会占用他大量的时间。</p>
<p>但是这个职位也同样需要有一些「一线」的工作，例如看产品数据，试用产品功能，讨论产品稿，思考产品方向，了解开发的业务进展等。</p>
<p>总之我还没有很好地描述和定义清楚该职位的工作内容，很多时候我感觉自己插手的事情也相当多，当前的我还需要更多的学习和体会。</p>
<p>希望自己继续学习和总结。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5E8F"><a href="#u5E8F" class="headerlink" title="序"></a>序</h2><p>一转眼，创业四周年了。我从来没有想到过，我的职业生涯中，待得最久的是猿题库这家创业公司。2016 年 5 月 31 日，我们宣布了获]]>
    </summary>
    
      <category term="startup" scheme="http://blog.devtang.com/tags/startup/"/>
    
      <category term="summary" scheme="http://blog.devtang.com/categories/summary/"/>
    
  </entry>
  
</feed>
